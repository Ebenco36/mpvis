{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    }\n    // otherwise use standard mark groups\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n  return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\nfunction getPathGroups(model, details) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n  return [{\n    name: model.getName('pathgroup'),\n    type: 'group',\n    from: {\n      facet: {\n        name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n        data: model.requestDataName(DataSourceType.Main),\n        groupby: details\n      }\n    },\n    encode: {\n      update: {\n        width: {\n          field: {\n            group: 'width'\n          }\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }\n    },\n    // With subfacet for line/area group, need to use faceted data from above.\n    marks: getMarkGroup(model, {\n      fromPrefix: FACETED_PATH_PREFIX\n    })\n  }];\n}\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n  // Generate the mark\n  const [mark] = getMarkGroup(model, {\n    fromPrefix: STACK_GROUP_PREFIX\n  });\n  // Get the scale for the stacked field\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);\n  // Find the min/max of the pixel value on the stacked direction\n  const stackFieldGroup = (func, expr) => {\n    const vgFieldMinMax = [stackField({\n      prefix: 'min',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'min',\n      suffix: 'end',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'end',\n      expr\n    })];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n  let groupUpdate;\n  let innerGroupUpdate;\n  // Build the encoding for group and an inner group\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = {\n      ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n      x: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      x2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    };\n    // Inner group should revert the x translation, and pass height through\n    innerGroupUpdate = {\n      x: {\n        field: {\n          group: 'x'\n        },\n        mult: -1\n      },\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n    // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n  } else {\n    groupUpdate = {\n      ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n      y: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      y2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    };\n    innerGroupUpdate = {\n      y: {\n        field: {\n          group: 'y'\n        },\n        mult: -1\n      },\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n  }\n  // Deal with cornerRadius properties\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config);\n    // Move from mark to group\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    }\n    // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n    if (configValue) {\n      mark.encode.update[key] = {\n        value: 0\n      };\n    }\n  }\n  const groupby = [];\n  if (model.stack.groupbyChannels?.length > 0) {\n    for (const groupbyChannel of model.stack.groupbyChannels) {\n      // For bin and time unit, we have to add bin/timeunit -end channels.\n      const groupByField = model.fieldDef(groupbyChannel);\n      const field = vgField(groupByField);\n      if (field) {\n        groupby.push(field);\n      }\n      if (groupByField?.bin || groupByField?.timeUnit) {\n        groupby.push(vgField(groupByField, {\n          binSuffix: 'end'\n        }));\n      }\n    }\n  }\n  const strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity'];\n  // Generate stroke properties for the group\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return {\n        ...encode,\n        [prop]: mark.encode.update[prop]\n      };\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n      if (configValue !== undefined) {\n        return {\n          ...encode,\n          [prop]: signalOrValueRef(configValue)\n        };\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate);\n  // Apply strokeForeground and strokeOffset if stroke is used\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {\n      value: true\n    };\n    groupUpdate.strokeOffset = {\n      value: 0\n    };\n  }\n  return [{\n    type: 'group',\n    from: {\n      facet: {\n        data: model.requestDataName(DataSourceType.Main),\n        name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n        groupby,\n        aggregate: {\n          fields: [stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'end'\n          }), stackField({\n            suffix: 'end'\n          })],\n          ops: ['min', 'max', 'min', 'max']\n        }\n      }\n    },\n    encode: {\n      update: groupUpdate\n    },\n    marks: [{\n      type: 'group',\n      encode: {\n        update: innerGroupUpdate\n      },\n      marks: [mark]\n    }]\n  }];\n}\nexport function getSort(model) {\n  const {\n    encoding,\n    stack,\n    mark,\n    markDef,\n    config\n  } = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else if (s === null) {\n        return undefined;\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack?.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\nfunction getMarkGroup(model, opt = {\n  fromPrefix: ''\n}) {\n  const {\n    mark,\n    markDef,\n    encoding,\n    config\n  } = model;\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [{\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(clip ? {\n      clip: true\n    } : {}),\n    ...(style ? {\n      style\n    } : {}),\n    ...(key ? {\n      key: key.field\n    } : {}),\n    ...(sort ? {\n      sort\n    } : {}),\n    ...(interactive ? interactive : {}),\n    ...(aria === false ? {\n      aria\n    } : {}),\n    from: {\n      data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    },\n    ...(postEncodingTransform ? {\n      transform: postEncodingTransform\n    } : {})\n  }];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale?.get('selectionExtent') || yScale?.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount ? {\n    interactive: unitCount > 0 || model.mark === 'geoshape' || !!model.encoding.tooltip\n  } : null;\n}","map":{"version":3,"names":["isArray","isFieldDef","isValueDef","vgField","DataSourceType","isAggregate","pathGroupingFields","AREA","BAR","isPathMark","LINE","TRAIL","isSortByEncoding","isSortField","contains","getFirstDefined","isNullOrFalse","keys","omit","pick","VG_CORNERRADIUS_CHANNELS","getMarkConfig","getMarkPropOrConfig","getStyles","signalOrValueRef","sortParams","arc","area","bar","geoshape","image","line","trail","circle","point","square","rect","rule","text","tick","markCompiler","parseMarkGroups","model","mark","details","encoding","length","getPathGroups","hasCornerRadius","some","prop","markDef","config","stack","fieldDef","getGroupsForStackedBarWithCornerRadius","getMarkGroup","FACETED_PATH_PREFIX","name","getName","type","from","facet","requestDataName","Main","data","groupby","encode","update","width","field","group","height","marks","fromPrefix","STACK_GROUP_PREFIX","fieldScale","scaleName","fieldChannel","stackField","opt","stackFieldGroup","func","expr","vgFieldMinMax","prefix","suffix","map","join","groupUpdate","innerGroupUpdate","x","signal","x2","clip","value","mult","y","y2","key","configValue","groupbyChannels","groupbyChannel","groupByField","push","bin","timeUnit","binSuffix","strokeProperties","reduce","undefined","stroke","strokeForeground","strokeOffset","aggregate","fields","ops","getSort","order","dimensionChannel","orient","dimensionChannelDef","s","sort","op","fieldDefToSort","impute","scaleClip","projectionClip","style","interactive","interactiveFlag","aria","postEncodingTransform","vgMark","encodeEntry","transform","xScale","getScaleComponent","yScale","get","projection","component","isFit","selection","unitCount","parentCount","parent","tooltip"],"sources":["../../../../src/compile/mark/mark.ts"],"sourcesContent":[null],"mappings":";AAAA,SAAQA,OAAO,QAAO,WAAW;AACjC,SAAwBC,UAAU,EAAEC,UAAU,EAAEC,OAAO,QAAO,kBAAkB;AAChF,SAAQC,cAAc,QAAO,YAAY;AACzC,SAAQC,WAAW,EAAEC,kBAAkB,QAAO,gBAAgB;AAC9D,SAAQC,IAAI,EAAEC,GAAG,EAAEC,UAAU,EAAEC,IAAI,EAAQC,KAAK,QAAO,YAAY;AACnE,SAAQC,gBAAgB,EAAEC,WAAW,QAAO,YAAY;AACxD,SAAQC,QAAQ,EAAEC,eAAe,EAAEC,aAAa,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,QAAO,YAAY;AACrF,SAAkCC,wBAAwB,QAAO,mBAAmB;AACpF,SAAQC,aAAa,EAAEC,mBAAmB,EAAEC,SAAS,EAAEC,gBAAgB,EAAEC,UAAU,QAAO,WAAW;AAErG,SAAQC,GAAG,QAAO,OAAO;AACzB,SAAQC,IAAI,QAAO,QAAQ;AAC3B,SAAQC,GAAG,QAAO,OAAO;AAEzB,SAAQC,QAAQ,QAAO,YAAY;AACnC,SAAQC,KAAK,QAAO,SAAS;AAC7B,SAAQC,IAAI,EAAEC,KAAK,QAAO,QAAQ;AAClC,SAAQC,MAAM,EAAEC,KAAK,EAAEC,MAAM,QAAO,SAAS;AAC7C,SAAQC,IAAI,QAAO,QAAQ;AAC3B,SAAQC,IAAI,QAAO,QAAQ;AAC3B,SAAQC,IAAI,QAAO,QAAQ;AAC3B,SAAQC,IAAI,QAAO,QAAQ;AAE3B,MAAMC,YAAY,GAA+B;EAC/Cd,GAAG;EACHC,IAAI;EACJC,GAAG;EACHK,MAAM;EACNJ,QAAQ;EACRC,KAAK;EACLC,IAAI;EACJG,KAAK;EACLE,IAAI;EACJC,IAAI;EACJF,MAAM;EACNG,IAAI;EACJC,IAAI;EACJP;CACD;AAED,OAAM,SAAUS,eAAeA,CAACC,KAAgB;EAC9C,IAAI5B,QAAQ,CAAC,CAACJ,IAAI,EAAEH,IAAI,EAAEI,KAAK,CAAC,EAAE+B,KAAK,CAACC,IAAI,CAAC,EAAE;IAC7C,MAAMC,OAAO,GAAGtC,kBAAkB,CAACoC,KAAK,CAACC,IAAI,EAAED,KAAK,CAACG,QAAQ,CAAC;IAC9D,IAAID,OAAO,CAACE,MAAM,GAAG,CAAC,EAAE;MACtB,OAAOC,aAAa,CAACL,KAAK,EAAEE,OAAO,CAAC;;IAEtC;GACD,MAAM,IAAIF,KAAK,CAACC,IAAI,KAAKnC,GAAG,EAAE;IAC7B,MAAMwC,eAAe,GAAG5B,wBAAwB,CAAC6B,IAAI,CAACC,IAAI,IACxD5B,mBAAmB,CAAC4B,IAAI,EAAER,KAAK,CAACS,OAAO,EAAET,KAAK,CAACU,MAAM,CAAC,CACvD;IACD,IAAIV,KAAK,CAACW,KAAK,IAAI,CAACX,KAAK,CAACY,QAAQ,CAAC,MAAM,CAAC,IAAIN,eAAe,EAAE;MAC7D,OAAOO,sCAAsC,CAACb,KAAK,CAAC;;;EAIxD,OAAOc,YAAY,CAACd,KAAK,CAAC;AAC5B;AAEA,MAAMe,mBAAmB,GAAG,eAAe;AAE3C,SAASV,aAAaA,CAACL,KAAgB,EAAEE,OAAiB;EACxD;EAEA,OAAO,CACL;IACEc,IAAI,EAAEhB,KAAK,CAACiB,OAAO,CAAC,WAAW,CAAC;IAChCC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;MACJC,KAAK,EAAE;QACLJ,IAAI,EAAED,mBAAmB,GAAGf,KAAK,CAACqB,eAAe,CAAC3D,cAAc,CAAC4D,IAAI,CAAC;QACtEC,IAAI,EAAEvB,KAAK,CAACqB,eAAe,CAAC3D,cAAc,CAAC4D,IAAI,CAAC;QAChDE,OAAO,EAAEtB;;KAEZ;IACDuB,MAAM,EAAE;MACNC,MAAM,EAAE;QACNC,KAAK,EAAE;UAACC,KAAK,EAAE;YAACC,KAAK,EAAE;UAAO;QAAC,CAAC;QAChCC,MAAM,EAAE;UAACF,KAAK,EAAE;YAACC,KAAK,EAAE;UAAQ;QAAC;;KAEpC;IACD;IACAE,KAAK,EAAEjB,YAAY,CAACd,KAAK,EAAE;MAACgC,UAAU,EAAEjB;IAAmB,CAAC;GAC7D,CACF;AACH;AAEA,MAAMkB,kBAAkB,GAAG,cAAc;AAEzC;;;;;AAKA,SAASpB,sCAAsCA,CAACb,KAAgB;EAC9D;EACA,MAAM,CAACC,IAAI,CAAC,GAAGa,YAAY,CAACd,KAAK,EAAE;IAACgC,UAAU,EAAEC;EAAkB,CAAC,CAAC;EAEpE;EACA,MAAMC,UAAU,GAAGlC,KAAK,CAACmC,SAAS,CAACnC,KAAK,CAACW,KAAK,CAACyB,YAAY,CAAC;EAC5D,MAAMC,UAAU,GAAGA,CAACC,GAAA,GAAsB,EAAE,KAAKtC,KAAK,CAACvC,OAAO,CAACuC,KAAK,CAACW,KAAK,CAACyB,YAAY,EAAEE,GAAG,CAAC;EAC7F;EACA,MAAMC,eAAe,GAAGA,CAACC,IAAmB,EAAEC,IAAwB,KAAI;IACxE,MAAMC,aAAa,GAAG,CACpBL,UAAU,CAAC;MAACM,MAAM,EAAE,KAAK;MAAEC,MAAM,EAAE,OAAO;MAAEH;IAAI,CAAC,CAAC,EAClDJ,UAAU,CAAC;MAACM,MAAM,EAAE,KAAK;MAAEC,MAAM,EAAE,OAAO;MAAEH;IAAI,CAAC,CAAC,EAClDJ,UAAU,CAAC;MAACM,MAAM,EAAE,KAAK;MAAEC,MAAM,EAAE,KAAK;MAAEH;IAAI,CAAC,CAAC,EAChDJ,UAAU,CAAC;MAACM,MAAM,EAAE,KAAK;MAAEC,MAAM,EAAE,KAAK;MAAEH;IAAI,CAAC,CAAC,CACjD;IACD,OAAO,GAAGD,IAAI,IAAIE,aAAa,CAACG,GAAG,CAACjB,KAAK,IAAI,UAAUM,UAAU,KAAKN,KAAK,GAAG,CAAC,CAACkB,IAAI,CAAC,GAAG,CAAC,GAAG;EAC9F,CAAC;EAED,IAAIC,WAA0B;EAC9B,IAAIC,gBAA+B;EAEnC;EACA,IAAIhD,KAAK,CAACW,KAAK,CAACyB,YAAY,KAAK,GAAG,EAAE;IACpC;IACA;IACAW,WAAW,GAAG;MACZ,GAAGtE,IAAI,CAACwB,IAAI,CAACwB,MAAM,CAACC,MAAM,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAGhD,wBAAwB,CAAC,CAAC;MACrFuE,CAAC,EAAE;QAACC,MAAM,EAAEX,eAAe,CAAC,KAAK,EAAE,OAAO;MAAC,CAAC;MAC5CY,EAAE,EAAE;QAACD,MAAM,EAAEX,eAAe,CAAC,KAAK,EAAE,OAAO;MAAC,CAAC;MAC7Ca,IAAI,EAAE;QAACC,KAAK,EAAE;MAAI;KACnB;IACD;IACAL,gBAAgB,GAAG;MACjBC,CAAC,EAAE;QAACrB,KAAK,EAAE;UAACC,KAAK,EAAE;QAAG,CAAC;QAAEyB,IAAI,EAAE,CAAC;MAAC,CAAC;MAClCxB,MAAM,EAAE;QAACF,KAAK,EAAE;UAACC,KAAK,EAAE;QAAQ;MAAC;KAClC;IACD;IACA;IACA5B,IAAI,CAACwB,MAAM,CAACC,MAAM,GAAG;MACnB,GAAGlD,IAAI,CAACyB,IAAI,CAACwB,MAAM,CAACC,MAAM,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;MAC9CI,MAAM,EAAE;QAACF,KAAK,EAAE;UAACC,KAAK,EAAE;QAAQ;MAAC;KAClC;GACF,MAAM;IACLkB,WAAW,GAAG;MACZ,GAAGtE,IAAI,CAACwB,IAAI,CAACwB,MAAM,CAACC,MAAM,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;MACvD6B,CAAC,EAAE;QAACL,MAAM,EAAEX,eAAe,CAAC,KAAK,EAAE,OAAO;MAAC,CAAC;MAC5CiB,EAAE,EAAE;QAACN,MAAM,EAAEX,eAAe,CAAC,KAAK,EAAE,OAAO;MAAC,CAAC;MAC7Ca,IAAI,EAAE;QAACC,KAAK,EAAE;MAAI;KACnB;IACDL,gBAAgB,GAAG;MACjBO,CAAC,EAAE;QAAC3B,KAAK,EAAE;UAACC,KAAK,EAAE;QAAG,CAAC;QAAEyB,IAAI,EAAE,CAAC;MAAC,CAAC;MAClC3B,KAAK,EAAE;QAACC,KAAK,EAAE;UAACC,KAAK,EAAE;QAAO;MAAC;KAChC;IACD5B,IAAI,CAACwB,MAAM,CAACC,MAAM,GAAG;MACnB,GAAGlD,IAAI,CAACyB,IAAI,CAACwB,MAAM,CAACC,MAAM,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;MAC9CC,KAAK,EAAE;QAACC,KAAK,EAAE;UAACC,KAAK,EAAE;QAAO;MAAC;KAChC;;EAGH;EACA,KAAK,MAAM4B,GAAG,IAAI/E,wBAAwB,EAAE;IAC1C,MAAMgF,WAAW,GAAG/E,aAAa,CAAC8E,GAAG,EAAEzD,KAAK,CAACS,OAAO,EAAET,KAAK,CAACU,MAAM,CAAC;IACnE;IACA,IAAIT,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAC+B,GAAG,CAAC,EAAE;MAC3BV,WAAW,CAACU,GAAG,CAAC,GAAGxD,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAC+B,GAAG,CAAC;MAC1C,OAAOxD,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAC+B,GAAG,CAAC;KAC/B,MAAM,IAAIC,WAAW,EAAE;MACtBX,WAAW,CAACU,GAAG,CAAC,GAAG3E,gBAAgB,CAAC4E,WAAW,CAAC;;IAElD;IACA,IAAIA,WAAW,EAAE;MACfzD,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAC+B,GAAG,CAAC,GAAG;QAACJ,KAAK,EAAE;MAAC,CAAC;;;EAIxC,MAAM7B,OAAO,GAAa,EAAE;EAE5B,IAAIxB,KAAK,CAACW,KAAK,CAACgD,eAAe,EAAEvD,MAAM,GAAG,CAAC,EAAE;IAC3C,KAAK,MAAMwD,cAAc,IAAI5D,KAAK,CAACW,KAAK,CAACgD,eAAe,EAAE;MACxD;MACA,MAAME,YAAY,GAAG7D,KAAK,CAACY,QAAQ,CAACgD,cAAc,CAAC;MACnD,MAAMhC,KAAK,GAAGnE,OAAO,CAACoG,YAAY,CAAC;MACnC,IAAIjC,KAAK,EAAE;QACTJ,OAAO,CAACsC,IAAI,CAAClC,KAAK,CAAC;;MAGrB,IAAIiC,YAAY,EAAEE,GAAG,IAAIF,YAAY,EAAEG,QAAQ,EAAE;QAC/CxC,OAAO,CAACsC,IAAI,CAACrG,OAAO,CAACoG,YAAY,EAAE;UAACI,SAAS,EAAE;QAAK,CAAC,CAAC,CAAC;;;;EAK7D,MAAMC,gBAAgB,GAAG,CACvB,QAAQ,EACR,aAAa,EACb,YAAY,EACZ,WAAW,EACX,YAAY,EACZ,kBAAkB,EAClB,kBAAkB,EAClB,eAAe,CACP;EAEV;EACAnB,WAAW,GAAGmB,gBAAgB,CAACC,MAAM,CAAC,CAAC1C,MAAM,EAAEjB,IAAI,KAAI;IACrD,IAAIP,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAClB,IAAI,CAAC,EAAE;MAC5B,OAAO;QAAC,GAAGiB,MAAM;QAAE,CAACjB,IAAI,GAAGP,IAAI,CAACwB,MAAM,CAACC,MAAM,CAAClB,IAAI;MAAC,CAAC;KACrD,MAAM;MACL,MAAMkD,WAAW,GAAG/E,aAAa,CAAC6B,IAAI,EAAER,KAAK,CAACS,OAAO,EAAET,KAAK,CAACU,MAAM,CAAC;MACpE,IAAIgD,WAAW,KAAKU,SAAS,EAAE;QAC7B,OAAO;UAAC,GAAG3C,MAAM;UAAE,CAACjB,IAAI,GAAG1B,gBAAgB,CAAC4E,WAAW;QAAC,CAAC;OAC1D,MAAM;QACL,OAAOjC,MAAM;;;EAGnB,CAAC,EAAEsB,WAAW,CAAC;EAEf;EACA,IAAIA,WAAW,CAACsB,MAAM,EAAE;IACtBtB,WAAW,CAACuB,gBAAgB,GAAG;MAACjB,KAAK,EAAE;IAAI,CAAC;IAC5CN,WAAW,CAACwB,YAAY,GAAG;MAAClB,KAAK,EAAE;IAAC,CAAC;;EAGvC,OAAO,CACL;IACEnC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;MACJC,KAAK,EAAE;QACLG,IAAI,EAAEvB,KAAK,CAACqB,eAAe,CAAC3D,cAAc,CAAC4D,IAAI,CAAC;QAChDN,IAAI,EAAEiB,kBAAkB,GAAGjC,KAAK,CAACqB,eAAe,CAAC3D,cAAc,CAAC4D,IAAI,CAAC;QACrEE,OAAO;QACPgD,SAAS,EAAE;UACTC,MAAM,EAAE,CACNpC,UAAU,CAAC;YAACO,MAAM,EAAE;UAAO,CAAC,CAAC,EAC7BP,UAAU,CAAC;YAACO,MAAM,EAAE;UAAO,CAAC,CAAC,EAC7BP,UAAU,CAAC;YAACO,MAAM,EAAE;UAAK,CAAC,CAAC,EAC3BP,UAAU,CAAC;YAACO,MAAM,EAAE;UAAK,CAAC,CAAC,CAC5B;UACD8B,GAAG,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK;;;KAGrC;IACDjD,MAAM,EAAE;MACNC,MAAM,EAAEqB;KACT;IACDhB,KAAK,EAAE,CACL;MACEb,IAAI,EAAE,OAAO;MACbO,MAAM,EAAE;QAACC,MAAM,EAAEsB;MAAgB,CAAC;MAClCjB,KAAK,EAAE,CAAC9B,IAAI;KACb;GAEJ,CACF;AACH;AAEA,OAAM,SAAU0E,OAAOA,CAAC3E,KAAgB;EACtC,MAAM;IAACG,QAAQ;IAAEQ,KAAK;IAAEV,IAAI;IAAEQ,OAAO;IAAEC;EAAM,CAAC,GAAGV,KAAK;EACtD,MAAM4E,KAAK,GAAGzE,QAAQ,CAACyE,KAAK;EAC5B,IACG,CAACtH,OAAO,CAACsH,KAAK,CAAC,IAAIpH,UAAU,CAACoH,KAAK,CAAC,IAAItG,aAAa,CAACsG,KAAK,CAACvB,KAAK,CAAC,IAClE,CAACuB,KAAK,IAAItG,aAAa,CAACM,mBAAmB,CAAC,OAAO,EAAE6B,OAAO,EAAEC,MAAM,CAAC,CAAE,EACxE;IACA,OAAO0D,SAAS;GACjB,MAAM,IAAI,CAAC9G,OAAO,CAACsH,KAAK,CAAC,IAAIrH,UAAU,CAACqH,KAAK,CAAC,KAAK,CAACjE,KAAK,EAAE;IAC1D;IACA,OAAO5B,UAAU,CAAC6F,KAAK,EAAE;MAACnC,IAAI,EAAE;IAAO,CAAC,CAAC;GAC1C,MAAM,IAAI1E,UAAU,CAACkC,IAAI,CAAC,EAAE;IAC3B;IACA,MAAM4E,gBAAgB,GAAGpE,OAAO,CAACqE,MAAM,KAAK,YAAY,GAAG,GAAG,GAAG,GAAG;IACpE,MAAMC,mBAAmB,GAAG5E,QAAQ,CAAC0E,gBAAgB,CAAC;IACtD,IAAItH,UAAU,CAACwH,mBAAmB,CAAC,EAAE;MACnC,MAAMC,CAAC,GAAGD,mBAAmB,CAACE,IAAI;MAElC,IAAI3H,OAAO,CAAC0H,CAAC,CAAC,EAAE;QACd,OAAO;UACLpD,KAAK,EAAEnE,OAAO,CAACsH,mBAAmB,EAAE;YAACpC,MAAM,EAAEkC,gBAAgB;YAAEjC,MAAM,EAAE,YAAY;YAAEH,IAAI,EAAE;UAAO,CAAC;SACpG;OACF,MAAM,IAAItE,WAAW,CAAC6G,CAAC,CAAC,EAAE;QACzB,OAAO;UACLpD,KAAK,EAAEnE,OAAO,CACZ;YACE;YACA;YACA+G,SAAS,EAAE7G,WAAW,CAACqC,KAAK,CAACG,QAAQ,CAAC,GAAG6E,CAAC,CAACE,EAAE,GAAGd,SAAS;YACzDxC,KAAK,EAAEoD,CAAC,CAACpD;WACV,EACD;YAACa,IAAI,EAAE;UAAO,CAAC;SAElB;OACF,MAAM,IAAIvE,gBAAgB,CAAC8G,CAAC,CAAC,EAAE;QAC9B,MAAMG,cAAc,GAAGnF,KAAK,CAACY,QAAQ,CAACoE,CAAC,CAAC7E,QAAQ,CAAC;QACjD,OAAO;UACLyB,KAAK,EAAEnE,OAAO,CAAC0H,cAAc,EAAE;YAAC1C,IAAI,EAAE;UAAO,CAAC,CAAC;UAC/CmC,KAAK,EAAEI,CAAC,CAACJ;SACV;OACF,MAAM,IAAII,CAAC,KAAK,IAAI,EAAE;QACrB,OAAOZ,SAAS;OACjB,MAAM;QACL,OAAO;UACLxC,KAAK,EAAEnE,OAAO,CAACsH,mBAAmB,EAAE;YAClC;YACAd,SAAS,EAAEjE,KAAK,CAACW,KAAK,EAAEyE,MAAM,GAAG,KAAK,GAAGhB,SAAS;YAClD3B,IAAI,EAAE;WACP;SACF;;;IAGL,OAAO2B,SAAS;;EAElB,OAAOA,SAAS;AAClB;AAEA,SAAStD,YAAYA,CAACd,KAAgB,EAAEsC,GAAA,GAA4B;EAACN,UAAU,EAAE;AAAE,CAAC;EAClF,MAAM;IAAC/B,IAAI;IAAEQ,OAAO;IAAEN,QAAQ;IAAEO;EAAM,CAAC,GAAGV,KAAK;EAE/C,MAAMoD,IAAI,GAAG/E,eAAe,CAACoC,OAAO,CAAC2C,IAAI,EAAEiC,SAAS,CAACrF,KAAK,CAAC,EAAEsF,cAAc,CAACtF,KAAK,CAAC,CAAC;EACnF,MAAMuF,KAAK,GAAG1G,SAAS,CAAC4B,OAAO,CAAC;EAChC,MAAMgD,GAAG,GAAGtD,QAAQ,CAACsD,GAAG;EACxB,MAAMwB,IAAI,GAAGN,OAAO,CAAC3E,KAAK,CAAC;EAC3B,MAAMwF,WAAW,GAAGC,eAAe,CAACzF,KAAK,CAAC;EAC1C,MAAM0F,IAAI,GAAG9G,mBAAmB,CAAC,MAAM,EAAE6B,OAAO,EAAEC,MAAM,CAAC;EAEzD,MAAMiF,qBAAqB,GAAG7F,YAAY,CAACG,IAAI,CAAC,CAAC0F,qBAAqB,GAClE7F,YAAY,CAACG,IAAI,CAAC,CAAC0F,qBAAqB,CAAC3F,KAAK,CAAC,GAC/C,IAAI;EAER,OAAO,CACL;IACEgB,IAAI,EAAEhB,KAAK,CAACiB,OAAO,CAAC,OAAO,CAAC;IAC5BC,IAAI,EAAEpB,YAAY,CAACG,IAAI,CAAC,CAAC2F,MAAM;IAC/B,IAAIxC,IAAI,GAAG;MAACA,IAAI,EAAE;IAAI,CAAC,GAAG,EAAE,CAAC;IAC7B,IAAImC,KAAK,GAAG;MAACA;IAAK,CAAC,GAAG,EAAE,CAAC;IACzB,IAAI9B,GAAG,GAAG;MAACA,GAAG,EAAEA,GAAG,CAAC7B;IAAK,CAAC,GAAG,EAAE,CAAC;IAChC,IAAIqD,IAAI,GAAG;MAACA;IAAI,CAAC,GAAG,EAAE,CAAC;IACvB,IAAIO,WAAW,GAAGA,WAAW,GAAG,EAAE,CAAC;IACnC,IAAIE,IAAI,KAAK,KAAK,GAAG;MAACA;IAAI,CAAC,GAAG,EAAE,CAAC;IACjCvE,IAAI,EAAE;MAACI,IAAI,EAAEe,GAAG,CAACN,UAAU,GAAGhC,KAAK,CAACqB,eAAe,CAAC3D,cAAc,CAAC4D,IAAI;IAAC,CAAC;IACzEG,MAAM,EAAE;MACNC,MAAM,EAAE5B,YAAY,CAACG,IAAI,CAAC,CAAC4F,WAAW,CAAC7F,KAAK;KAC7C;IACD,IAAI2F,qBAAqB,GACrB;MACEG,SAAS,EAAEH;KACZ,GACD,EAAE;GACP,CACF;AACH;AAEA;;;;;AAKA,SAASN,SAASA,CAACrF,KAAgB;EACjC,MAAM+F,MAAM,GAAG/F,KAAK,CAACgG,iBAAiB,CAAC,GAAG,CAAC;EAC3C,MAAMC,MAAM,GAAGjG,KAAK,CAACgG,iBAAiB,CAAC,GAAG,CAAC;EAC3C,OAAOD,MAAM,EAAEG,GAAG,CAAC,iBAAiB,CAAC,IAAID,MAAM,EAAEC,GAAG,CAAC,iBAAiB,CAAC,GAAG,IAAI,GAAG9B,SAAS;AAC5F;AAEA;;;;AAIA,SAASkB,cAAcA,CAACtF,KAAgB;EACtC,MAAMmG,UAAU,GAAGnG,KAAK,CAACoG,SAAS,CAACD,UAAU;EAC7C,OAAOA,UAAU,IAAI,CAACA,UAAU,CAACE,KAAK,GAAG,IAAI,GAAGjC,SAAS;AAC3D;AAEA;;;AAGA,SAASqB,eAAeA,CAACzF,KAAgB;EACvC,IAAI,CAACA,KAAK,CAACoG,SAAS,CAACE,SAAS,EAAE,OAAO,IAAI;EAC3C,MAAMC,SAAS,GAAGhI,IAAI,CAACyB,KAAK,CAACoG,SAAS,CAACE,SAAS,CAAC,CAAClG,MAAM;EACxD,IAAIoG,WAAW,GAAGD,SAAS;EAC3B,IAAIE,MAAM,GAAGzG,KAAK,CAACyG,MAAM;EACzB,OAAOA,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;IAClCA,WAAW,GAAGjI,IAAI,CAACkI,MAAM,CAACL,SAAS,CAACE,SAAS,CAAC,CAAClG,MAAM;IACrDqG,MAAM,GAAGA,MAAM,CAACA,MAAM;;EAExB,OAAOD,WAAW,GACd;IACEhB,WAAW,EAAEe,SAAS,GAAG,CAAC,IAAIvG,KAAK,CAACC,IAAI,KAAK,UAAU,IAAI,CAAC,CAACD,KAAK,CAACG,QAAQ,CAACuG;GAC7E,GACD,IAAI;AACV"},"metadata":{},"sourceType":"module","externalDependencies":[]}