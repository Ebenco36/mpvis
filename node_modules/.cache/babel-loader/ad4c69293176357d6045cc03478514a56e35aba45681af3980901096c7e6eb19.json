{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, error, isString, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isContinuous, isDiscretizing } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\nfunction parseAutosize(spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\nconst number = _ => +_ || 0;\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\nfunction parsePadding(spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]);\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\nfunction applyDefaults(encode, type, role, style, config) {\n  const defaults = {},\n    enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n  if (value === undefined) {\n    value = null;\n  }\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n  return value;\n}\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\nfunction resolveField(ref) {\n  let object, level, field;\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n  return object + '[' + field + ']';\n}\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n    if (value == null) value = '0';\n  }\n  return value;\n}\nfunction rule(enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n  return code;\n}\nfunction parseEncode(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n  return params;\n}\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n    fields = {};\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\nconst OUTER = 'outer',\n  OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\nfunction parseSignal(signal, scope) {\n  const name = signal.name;\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  };\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef$1('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nconst Scope$1 = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n    entry = streamParameters({\n      merge: list\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n    entry = streamParameters({\n      stream: id\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n  if (stream.consume) {\n    entry.consume = true;\n  }\n  return entry;\n}\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate(spec, scope, target) {\n  const encode = spec.encode,\n    entry = {\n      target: target\n    };\n  let events = spec.events,\n    update = spec.update,\n    sources = [];\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\nfunction parseSignalUpdates(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n    fields = domain.fields.reduce((dom, d) => {\n      d = isString(d) ? {\n        data: data,\n        field: d\n      } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n      dom.push(d);\n      return dom;\n    }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n    coll = Collect({});\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  }));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\nfunction parseProjection(proj, scope) {\n  const config = scope.config.projection || {},\n    params = {};\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n  scope.addProjection(proj.name, params);\n}\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\nfunction guideGroup(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n    band,\n    extra;\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\nfunction guideMark(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\nfunction legendGradient(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  let enter, start, stop, width, height;\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\nfunction legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  let u,\n    v,\n    uu,\n    vv,\n    adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n  baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\nfunction legendGradientLabels(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = encoder(_.gradientThickness()),\n    length = _.gradientLength();\n  let overlap = _('labelOverlap'),\n    enter,\n    update,\n    u,\n    v,\n    adjust = '';\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\n// userEncode is top-level, includes entries, symbols, labels\nfunction legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n    entries = userEncode.entries,\n    interactive = !!(entries && entries.interactive),\n    name = entries ? entries.name : undefined,\n    height = _('clipHeight'),\n    symbolOffset = _('symbolOffset'),\n    valueRef = {\n      data: 'value'\n    },\n    xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n    yEncode = height ? encoder(height) : {\n      field: Size\n    },\n    index = `datum.${Index}`,\n    ncols = `max(1, ${columns})`;\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n    baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n  isR = 'item.orient === \"right\"',\n  isLR = `(${isL} || ${isR})`,\n  isVG = `datum.vgrad && ${isLR}`,\n  baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n  alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n  exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n  exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n  exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n  exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\nfunction legendTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction clip(clip, scope) {\n  let expr;\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n  return expr ? scope.signalRef(expr) : !!clip;\n}\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\nfunction getRole(spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\nfunction definition(spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\nfunction interactive(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\nfunction parseTransform(spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n    n = def.params.length;\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n    value = spec[def.name];\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\nfunction parseData$1(from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n  this.input = input; // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n    values = entries[n - 1],\n    output = entries[n - 2];\n  let input = entries[0],\n    aggr = null,\n    i = 1;\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n  return new DataScope(scope, input, output, values, aggr);\n};\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n    sort = sortKey(counts);\n  let k = fieldKey(field),\n    v,\n    op;\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field);\n    let v, a, p;\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n    return v.ref;\n  },\n  tuplesRef() {\n    return ref(this.values);\n  },\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\nfunction parseFacet(spec, scope, group) {\n  const facet = spec.from.facet,\n    name = facet.name,\n    data = getDataRef(facet, scope);\n  let op;\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n    source = subscope.add(Collect()),\n    values = subscope.add(Sieve({\n      pulse: ref(source)\n    }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\nfunction parseSubflow(spec, scope, input) {\n  const op = scope.add(PreFacet({\n      pulse: input.pulse\n    })),\n    subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\nfunction parseTrigger(spec, scope, name) {\n  const remove = spec.remove,\n    insert = spec.insert,\n    toggle = spec.toggle,\n    modify = spec.modify,\n    values = spec.values,\n    op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\nfunction parseMark(spec, scope) {\n  const role = getRole(spec),\n    group = spec.type === GroupMark,\n    facet = spec.from && spec.from.facet,\n    overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n    ops,\n    op,\n    store,\n    enc,\n    name,\n    layoutRef,\n    boundRef;\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData$1(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  }));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  })));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n        md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({\n      pulse: boundRef\n    })),\n    sieve = scope.add(Sieve({\n      pulse: ref(render)\n    }, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n    bound = overlap.bound,\n    sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n  return ref(scope.add(Overlap(params)));\n}\nfunction parseLegend(spec, scope) {\n  const config = scope.config.legend,\n    encode = spec.encode || {},\n    _ = lookup(spec, config),\n    legendEncode = encode.legend || {},\n    name = legendEncode.name || undefined,\n    interactive = legendEncode.interactive,\n    style = legendEncode.style,\n    scales = {};\n  let scale = 0,\n    entryLayout,\n    params,\n    children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  };\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n    strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n    fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\nfunction parseTitle(spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n  const _ = lookup(spec, scope.config.title),\n    encode = spec.encode || {},\n    userEncode = encode.group || {},\n    name = userEncode.name || undefined,\n    interactive = userEncode.interactive,\n    style = userEncode.style,\n    children = [];\n\n  // single-element data source for group title\n  const datum = {},\n    dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n      value: 0\n    },\n    text = spec.text,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n      value: 0\n    },\n    text = spec.subtitle,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction parseData(data, scope) {\n  const transforms = [];\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n    modify = false,\n    generate = false,\n    upstream,\n    i,\n    n,\n    t,\n    m;\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b;\n\n// condition on axis y-direction\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n  return null;\n}\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\nfunction axisConfig(spec, scope) {\n  var config = scope.config,\n    style = config.style,\n    axis = config.axis,\n    band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n    orient = spec.orient,\n    xy,\n    or,\n    key;\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n      orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\nfunction axisDomain(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    orient = spec.orient;\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\nfunction axisGrid(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    vscale = spec.gridScale,\n    sign = getSign(orient, 1, -1),\n    offset = offsetValue(spec.offset, sign);\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ;else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n  return offset;\n}\nfunction axisTicks(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\nfunction axisLabels(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    scale = spec.scale,\n    sign = getSign(orient, -1, 1),\n    flush = deref(_('labelFlush')),\n    flushOffset = deref(_('labelFlushOffset')),\n    labelAlign = _('labelAlign'),\n    labelBaseline = _('labelBaseline');\n  let flushOn = flush === 0 || !!flush,\n    update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n  const bound = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\nfunction axisTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n  const autoY = auto(_('titleX'), 'x'),\n    autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\nfunction parseAxis(spec, scope) {\n  const config = axisConfig(spec, scope),\n    encode = spec.encode || {},\n    axisEncode = encode.axis || {},\n    name = axisEncode.name || undefined,\n    interactive = axisEncode.interactive,\n    style = axisEncode.style,\n    _ = lookup(spec, config),\n    band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\nfunction parseScope(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n    scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n  return scope;\n}\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\nfunction parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  })));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  }));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n    signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n    pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n    map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n  fork() {\n    return new Subscope(this);\n  },\n  isSubscope() {\n    return this._subid > 0;\n  },\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n    return op;\n  },\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n    return this;\n  },\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n  parent() {\n    return peek(this._parent);\n  },\n  encode() {\n    return peek(this._encode);\n  },\n  lookup() {\n    return peek(this._lookup);\n  },\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n    const s = field.signal;\n    let f = this.field[s];\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n  compareRef(cmp) {\n    let signal = false;\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n    const fields = array(cmp.field).map(check),\n      orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n  keyRef(fields, flat) {\n    let signal = false;\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n      o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n        e = parseExpression(s, this),\n        op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.data[name] = dataScope;\n  },\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n  return code + ']';\n}\nfunction objectLambda(obj) {\n  let code = '{',\n    i = 0,\n    key,\n    value;\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults() {\n  const defaultFont = 'sans-serif',\n    defaultSymbolSize = 30,\n    defaultStrokeWidth = 2,\n    defaultColor = '#4c78a8',\n    black = '#000',\n    gray = '#888',\n    lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      },\n      view: {\n        fill: 'transparent'\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\nfunction parse(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };","map":{"version":3,"names":["isObject","isArray","extend","hasOwnProperty","array","stringValue","peek","error","isString","splitAccessPath","mergeConfig","parseExpression","parseSelector","isValidScaleType","isDiscrete","isQuantile","isContinuous","isDiscretizing","definition","definition$1","parseAutosize","spec","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","value","addEncode","object","name","set","isEncoder","length","update","addEncoders","enter","extendEncode","encode","extra","skip","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefaults","role","style","config","defaults","props","applyDefault","String","startsWith","group","mark","forEach","scaleRef","scale","field","entry$1","enc","gradient","color","undefined","exponent","property","mult","offset","round","_color","x","y","z","map","join","c","h","l","s","a","b","r","g","args","start","stop","count","pop","unshift","ref","resolveField","datum","level","parent","Math","max","range","band","rule","code","test","parseEncode","scope","params","encoders","$encode","parseBlock","block","marktype","channels","fields","parse$1","expr","$expr","$fields","Object","keys","$output","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","entry","operator","$ref","refs","fieldRef$1","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","keyRef","flat","$key","$flat","Ascending","Descending","sortKey","sort","order","aggrField","Scope$1","View","isSignal","isExpr$1","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","method","merge","mergeStream","nestedStream","eventStream","eventSource","source","list","streamParameters","addStream","event","throttle","between","filter","param","concat","markname","markrole","filterMark","debounce","consume","item","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","initScale","addScale","domain","parseScale","getScale","parseScaleDomain","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","parseArray","dataLookupError","domainMin","domainMax","explicitDomain","multipleDomain","singularDomain","data","getData","valuesRef","parseSort","domainRef","extentRef","reduce","dom","d","fieldRef","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","$ingest","input","addDataPipeline","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","scheme","extent","schemeExtent","schemeCount","rangeStep","parseProjection","proj","projection","parseParameter$1","addProjection","Top","Left","Right","Bottom","Center","Vertical","Start","Middle","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","Shape","Fill","Stroke","StrokeWidth","StrokeDash","Opacity","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","getStyle","anchorExpr","e","m","alignExpr$1","tickBand","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","alignExpr","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","legendSymbolLayout","center","padding","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","legendTitle","orient","_anchor","anchor","angle","title","lineHeight","path","sphere","getRole","indexOf","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","parseParameter","parseIndexParameter","required","parseSubParameters","projectionRef","parameterValue","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","lookupRef","parseSubParameter","k","parseData$1","getDataRef","aggregate","output","DataScope","aggr","fromEntries","fieldKey","addSortField","cache","ds","optype","prototype","agg","tuplesRef","indataRef","parseFacet","subscope","fork","addData","subflow","$subflow","parse","toRuntime","parseSubflow","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","layout","store","layoutRef","boundRef","nested","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","popState","parseOverlap","render","sieve","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","parseLegend","legend","legendEncode","scales","entryLayout","children","legendType","scaleType","vgrad","entryEncode","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","sizeExpression","buildLegendEncode","scaleCount","titlePadding","cornerRadius","getChannel","getFontSize","angleExpr","parseTitle","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","dx","dy","parseData","transforms","analyze","generate","upstream","load","collect","$format","url","$request","modifies","derive","splice","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","axis","axisBand","xy","or","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","result","axisDomain","strokeCap","strokeOpacity","pos0","position","pos1","x2","y2","pos","axisGrid","vscale","gridScale","offsetValue","tickPos","sz","gridStart","gridEnd","axisTicks","tickSize","flushExpr","threshold","axisLabels","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisTitle","titlePos","autoLayout","auto","dim","autoY","autoX","parseAxis","axisEncode","ticks","grid","ticksRef","tickCount","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","axes","parseLambdas","rootEncode","parseView","root","collectSignals","eventConfig","locale","autosize","signalObject","pre","Scope","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","finish","vref","annotate","cmp","check","sig","o","hasOwnSignal","propertyLambda","addScaleProj","projectionType","dataScope","arrayLambda","objectLambda","defaultFont","defaultSymbolSize","defaultStrokeWidth","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","view","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","signalUpdates"],"sources":["/Users/ebenezerawotoro/Desktop/mpvis_app/node_modules/vega-parser/build/vega-parser.module.js"],"sourcesContent":["import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, error, isString, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isContinuous, isDiscretizing } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize (spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\nfunction parsePadding (spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]);\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults (encode, type, role, style, config) {\n  const defaults = {},\n    enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n  if (value === undefined) {\n    value = null;\n  }\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n  return value;\n}\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\nfunction resolveField(ref) {\n  let object, level, field;\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n  return object + '[' + field + ']';\n}\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n    if (value == null) value = '0';\n  }\n  return value;\n}\n\nfunction rule (enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n  return code;\n}\n\nfunction parseEncode (encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n  return params;\n}\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n    fields = {};\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n  OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\nfunction parseSignal (signal, scope) {\n  const name = signal.name;\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  };\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef$1('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nconst Scope$1 = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n    entry = streamParameters({\n      merge: list\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n    entry = streamParameters({\n      stream: id\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n  if (stream.consume) {\n    entry.consume = true;\n  }\n  return entry;\n}\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate (spec, scope, target) {\n  const encode = spec.encode,\n    entry = {\n      target: target\n    };\n  let events = spec.events,\n    update = spec.update,\n    sources = [];\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates (signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\n\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n    fields = domain.fields.reduce((dom, d) => {\n      d = isString(d) ? {\n        data: data,\n        field: d\n      } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n      dom.push(d);\n      return dom;\n    }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n    coll = Collect({});\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  }));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection (proj, scope) {\n  const config = scope.config.projection || {},\n    params = {};\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n  scope.addProjection(proj.name, params);\n}\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\n\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup (mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n    band,\n    extra;\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark (mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\n\nfunction legendGradient (spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  let enter, start, stop, width, height;\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  let u,\n    v,\n    uu,\n    vv,\n    adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n  baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\nfunction legendGradientLabels (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = encoder(_.gradientThickness()),\n    length = _.gradientLength();\n  let overlap = _('labelOverlap'),\n    enter,\n    update,\n    u,\n    v,\n    adjust = '';\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\n// userEncode is top-level, includes entries, symbols, labels\nfunction legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n    entries = userEncode.entries,\n    interactive = !!(entries && entries.interactive),\n    name = entries ? entries.name : undefined,\n    height = _('clipHeight'),\n    symbolOffset = _('symbolOffset'),\n    valueRef = {\n      data: 'value'\n    },\n    xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n    yEncode = height ? encoder(height) : {\n      field: Size\n    },\n    index = `datum.${Index}`,\n    ncols = `max(1, ${columns})`;\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n    baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n  isR = 'item.orient === \"right\"',\n  isLR = `(${isL} || ${isR})`,\n  isVG = `datum.vgrad && ${isLR}`,\n  baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n  alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n  exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n  exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n  exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n  exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\nfunction legendTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip (clip, scope) {\n  let expr;\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n  return expr ? scope.signalRef(expr) : !!clip;\n}\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole (spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition (spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive (spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\nfunction parseTransform (spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n    n = def.params.length;\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n    value = spec[def.name];\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1 (from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n  this.input = input; // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n    values = entries[n - 1],\n    output = entries[n - 2];\n  let input = entries[0],\n    aggr = null,\n    i = 1;\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n  return new DataScope(scope, input, output, values, aggr);\n};\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n    sort = sortKey(counts);\n  let k = fieldKey(field),\n    v,\n    op;\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field);\n    let v, a, p;\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n    return v.ref;\n  },\n  tuplesRef() {\n    return ref(this.values);\n  },\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\n\nfunction parseFacet (spec, scope, group) {\n  const facet = spec.from.facet,\n    name = facet.name,\n    data = getDataRef(facet, scope);\n  let op;\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n    source = subscope.add(Collect()),\n    values = subscope.add(Sieve({\n      pulse: ref(source)\n    }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow (spec, scope, input) {\n  const op = scope.add(PreFacet({\n      pulse: input.pulse\n    })),\n    subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger (spec, scope, name) {\n  const remove = spec.remove,\n    insert = spec.insert,\n    toggle = spec.toggle,\n    modify = spec.modify,\n    values = spec.values,\n    op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark (spec, scope) {\n  const role = getRole(spec),\n    group = spec.type === GroupMark,\n    facet = spec.from && spec.from.facet,\n    overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n    ops,\n    op,\n    store,\n    enc,\n    name,\n    layoutRef,\n    boundRef;\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData$1(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  }));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  })));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n        md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({\n      pulse: boundRef\n    })),\n    sieve = scope.add(Sieve({\n      pulse: ref(render)\n    }, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n    bound = overlap.bound,\n    sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend (spec, scope) {\n  const config = scope.config.legend,\n    encode = spec.encode || {},\n    _ = lookup(spec, config),\n    legendEncode = encode.legend || {},\n    name = legendEncode.name || undefined,\n    interactive = legendEncode.interactive,\n    style = legendEncode.style,\n    scales = {};\n  let scale = 0,\n    entryLayout,\n    params,\n    children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  };\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n    strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n    fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\nfunction parseTitle (spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n  const _ = lookup(spec, scope.config.title),\n    encode = spec.encode || {},\n    userEncode = encode.group || {},\n    name = userEncode.name || undefined,\n    interactive = userEncode.interactive,\n    style = userEncode.style,\n    children = [];\n\n  // single-element data source for group title\n  const datum = {},\n    dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n      value: 0\n    },\n    text = spec.text,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n      value: 0\n    },\n    text = spec.subtitle,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n    modify = false,\n    generate = false,\n    upstream,\n    i,\n    n,\n    t,\n    m;\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b;\n\n// condition on axis y-direction\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n  return null;\n}\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\nfunction axisConfig (spec, scope) {\n  var config = scope.config,\n    style = config.style,\n    axis = config.axis,\n    band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n    orient = spec.orient,\n    xy,\n    or,\n    key;\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n      orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    orient = spec.orient;\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid (spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    vscale = spec.gridScale,\n    sign = getSign(orient, 1, -1),\n    offset = offsetValue(spec.offset, sign);\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ; else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n  return offset;\n}\n\nfunction axisTicks (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\nfunction axisLabels (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    scale = spec.scale,\n    sign = getSign(orient, -1, 1),\n    flush = deref(_('labelFlush')),\n    flushOffset = deref(_('labelFlushOffset')),\n    labelAlign = _('labelAlign'),\n    labelBaseline = _('labelBaseline');\n  let flushOn = flush === 0 || !!flush,\n    update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n  const bound = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n  const autoY = auto(_('titleX'), 'x'),\n    autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis (spec, scope) {\n  const config = axisConfig(spec, scope),\n    encode = spec.encode || {},\n    axisEncode = encode.axis || {},\n    name = axisEncode.name || undefined,\n    interactive = axisEncode.interactive,\n    style = axisEncode.style,\n    _ = lookup(spec, config),\n    band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope (spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n    scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\nfunction parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  })));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  }));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n    signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n    pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n    map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n  fork() {\n    return new Subscope(this);\n  },\n  isSubscope() {\n    return this._subid > 0;\n  },\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n    return op;\n  },\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n    return this;\n  },\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n  parent() {\n    return peek(this._parent);\n  },\n  encode() {\n    return peek(this._encode);\n  },\n  lookup() {\n    return peek(this._lookup);\n  },\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n    const s = field.signal;\n    let f = this.field[s];\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n  compareRef(cmp) {\n    let signal = false;\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n    const fields = array(cmp.field).map(check),\n      orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n  keyRef(fields, flat) {\n    let signal = false;\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n      o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n        e = parseExpression(s, this),\n        op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.data[name] = dataScope;\n  },\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n  return code + ']';\n}\nfunction objectLambda(obj) {\n  let code = '{',\n    i = 0,\n    key,\n    value;\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults () {\n  const defaultFont = 'sans-serif',\n    defaultSymbolSize = 30,\n    defaultStrokeWidth = 2,\n    defaultColor = '#4c78a8',\n    black = '#000',\n    gray = '#888',\n    lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      },\n      view: {\n        fill: 'transparent'\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse (spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}