{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, getSecondaryRangeChannel, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  const {\n    config,\n    encoding,\n    markDef,\n    specifiedScales\n  } = model;\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef['timeUnit'];\n        const type = fieldOrDatumDef.type;\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {\n                signal: valueExpr(specifiedScale[property], {\n                  type,\n                  timeUnit\n                })\n              }, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property], true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n        }\n      } else {\n        const value = property in scaleRules ? scaleRules[property]({\n          model,\n          channel,\n          fieldOrDatumDef,\n          scaleType,\n          scalePadding,\n          scalePaddingInner,\n          domain: specifiedScale.domain,\n          domainMin: specifiedScale.domainMin,\n          domainMax: specifiedScale.domainMax,\n          markDef,\n          config,\n          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n          hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n        }) : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\nexport const scaleRules = {\n  bins: ({\n    model,\n    fieldOrDatumDef\n  }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined,\n  interpolate: ({\n    channel,\n    fieldOrDatumDef\n  }) => interpolate(channel, fieldOrDatumDef.type),\n  nice: ({\n    scaleType,\n    channel,\n    domain,\n    domainMin,\n    domainMax,\n    fieldOrDatumDef\n  }) => nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n  padding: ({\n    channel,\n    scaleType,\n    fieldOrDatumDef,\n    markDef,\n    config\n  }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n  paddingInner: ({\n    scalePadding,\n    channel,\n    markDef,\n    scaleType,\n    config,\n    hasNestedOffsetScale\n  }) => paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n  paddingOuter: ({\n    scalePadding,\n    channel,\n    scaleType,\n    scalePaddingInner,\n    config,\n    hasNestedOffsetScale\n  }) => paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n  reverse: ({\n    fieldOrDatumDef,\n    scaleType,\n    channel,\n    config\n  }) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({\n    channel,\n    fieldOrDatumDef,\n    domain,\n    markDef,\n    scaleType,\n    config,\n    hasSecondaryRangeChannel\n  }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel)\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit;\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n\n          return 0;\n        }));\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n  if (getFieldDef(fieldOrDatumDef)?.bin || isArray(specifiedDomain) || domainMax != null || domainMin != null || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n      const {\n        type,\n        orient\n      } = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig, hasNestedOffsetScale = false) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    const {\n      bandPaddingOuter,\n      bandWithNestedOffsetPaddingOuter\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: `${paddingInnerValue.signal}/2`\n      } : paddingInnerValue / 2);\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: `!${scaleConfig.xReverse.signal}`\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType, scaleConfig, hasSecondaryRangeChannel) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n    return scaleConfig?.zero;\n  }\n  return false;\n}","map":{"version":3,"names":["isArray","isBinned","isBinning","isBinParams","COLOR","FILL","getSecondaryRangeChannel","isXorY","isXorYOffset","POLAR_POSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","STROKE","getFieldDef","getFieldOrDatumDef","isFieldDef","valueExpr","isDateTime","channelHasNestedOffsetScale","log","channelScalePropertyIncompatability","hasContinuousDomain","isContinuousToContinuous","isContinuousToDiscrete","ScaleType","scaleTypeSupportProperty","util","contains","getFirstDefined","keys","isSignalRef","getBinSignalName","isUnitModel","SignalRefWrapper","mergeValuesWithExplicit","tieBreakByComparing","parseUnitScaleRange","parseScaleProperty","model","property","parseUnitScaleProperty","parseNonUnitScaleProperty","localScaleComponents","component","scales","config","encoding","markDef","specifiedScales","channel","specifiedScale","localScaleCmpt","mergedScaleCmpt","getScaleComponent","fieldOrDatumDef","specifiedValue","scaleType","get","scalePadding","scalePaddingInner","supportedByScaleType","channelIncompatability","undefined","warn","message","scalePropertyNotWorkWithScaleType","timeUnit","type","set","signal","copyKeyFromObject","value","scaleRules","domain","domainMin","domainMax","hasNestedOffsetScale","hasSecondaryRangeChannel","scale","bins","interpolate","nice","padding","bar","paddingInner","paddingOuter","reverse","sort","zero","parseScaleRange","child","children","valueWithExplicit","childComponent","childValueWithExplicit","getWithExplicit","v1","v2","step","setWithExplicit","fieldDef","bin","binSignal","field","getSignalName","specifiedDomain","TIME","UTC","scaleConfig","barConfig","continuousPadding","orient","continuousBandSize","POINT","pointPadding","paddingValue","mark","bandPaddingInner","barBandPaddingInner","rectBandPaddingInner","bandWithNestedOffsetPaddingInner","BAND","offsetBandPaddingInner","paddingInnerValue","bandPaddingOuter","bandWithNestedOffsetPaddingOuter","offsetBandPaddingOuter","xReverse","hasCustomDomain","first","last","length"],"sources":["../../../../src/compile/scale/properties.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}