{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { vgField } from '../../channeldef';\nimport { getDateTimePartAndStep, getSmallestTimeUnitPart, getTimeUnitParts, isBinnedTimeUnit, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nimport { isRectBasedMark } from '../../mark';\nfunction isTimeUnitTransformComponent(timeUnitComponent) {\n  return timeUnitComponent.as !== undefined;\n}\nfunction offsetAs(field) {\n  return `${field}_end`;\n}\nexport class TimeUnitNode extends DataFlowNode {\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n  constructor(parent, formula) {\n    super(parent);\n    this.formula = formula;\n  }\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n      const {\n        field,\n        timeUnit\n      } = fieldDef;\n      if (timeUnit) {\n        let component;\n        if (isBinnedTimeUnit(timeUnit)) {\n          // For binned time unit, only produce end if the mark is a rect-based mark (rect, bar, image, arc), which needs \"range\".\n          if (isUnitModel(model)) {\n            const {\n              mark\n            } = model;\n            if (isRectBasedMark(mark) || !!fieldDef.bandPosition) {\n              component = {\n                timeUnit: normalizeTimeUnit(timeUnit),\n                field\n              };\n            }\n          }\n        } else {\n          component = {\n            as: vgField(fieldDef, {\n              forAs: true\n            }),\n            field,\n            timeUnit\n          };\n        }\n        if (component) {\n          timeUnitComponent[hash(component)] = component;\n        }\n      }\n      return timeUnitComponent;\n    }, {});\n    if (isEmpty(formula)) {\n      return null;\n    }\n    return new TimeUnitNode(parent, formula);\n  }\n  static makeFromTransform(parent, t) {\n    const {\n      timeUnit,\n      ...other\n    } = {\n      ...t\n    };\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n    const component = {\n      ...other,\n      timeUnit: normalizedTimeUnit\n    };\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  merge(other) {\n    this.formula = {\n      ...this.formula\n    };\n    // if the same hash happen twice, merge\n    for (const key in other.formula) {\n      if (!this.formula[key]) {\n        // copy if it's not a duplicate\n        this.formula[key] = other.formula[key];\n      }\n    }\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n  /**\n   * Remove time units coming from the other node.\n   */\n  removeFormulas(fields) {\n    const newFormula = {};\n    for (const [key, timeUnitComponent] of entries(this.formula)) {\n      const fieldAs = isTimeUnitTransformComponent(timeUnitComponent) ? timeUnitComponent.as : `${timeUnitComponent.field}_end`;\n      if (!fields.has(fieldAs)) {\n        newFormula[key] = timeUnitComponent;\n      }\n    }\n    this.formula = newFormula;\n  }\n  producedFields() {\n    return new Set(vals(this.formula).map(f => {\n      return isTimeUnitTransformComponent(f) ? f.as : offsetAs(f.field);\n    }));\n  }\n  dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n  hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n  assemble() {\n    const transforms = [];\n    for (const f of vals(this.formula)) {\n      if (isTimeUnitTransformComponent(f)) {\n        const {\n          field,\n          as,\n          timeUnit\n        } = f;\n        const {\n          unit,\n          utc,\n          ...params\n        } = normalizeTimeUnit(timeUnit);\n        transforms.push({\n          field: replacePathInField(field),\n          type: 'timeunit',\n          ...(unit ? {\n            units: getTimeUnitParts(unit)\n          } : {}),\n          ...(utc ? {\n            timezone: 'utc'\n          } : {}),\n          ...params,\n          as: [as, `${as}_end`]\n        });\n      } else if (f) {\n        const {\n          field,\n          timeUnit\n        } = f;\n        const smallestUnit = getSmallestTimeUnitPart(timeUnit?.unit);\n        const {\n          part,\n          step\n        } = getDateTimePartAndStep(smallestUnit, timeUnit.step);\n        transforms.push({\n          type: 'formula',\n          expr: `timeOffset('${part}', datum['${field}'], ${step})`,\n          as: offsetAs(field)\n        });\n      }\n    }\n    return transforms;\n  }\n}","map":{"version":3,"names":["vgField","getDateTimePartAndStep","getSmallestTimeUnitPart","getTimeUnitParts","isBinnedTimeUnit","normalizeTimeUnit","duplicate","entries","hash","isEmpty","replacePathInField","vals","isUnitModel","DataFlowNode","isRectBasedMark","isTimeUnitTransformComponent","timeUnitComponent","as","undefined","offsetAs","field","TimeUnitNode","clone","formula","constructor","parent","makeFromEncoding","model","reduceFieldDef","fieldDef","timeUnit","component","mark","bandPosition","forAs","makeFromTransform","t","other","normalizedTimeUnit","merge","key","child","children","removeChild","remove","removeFormulas","fields","newFormula","fieldAs","has","producedFields","Set","map","f","dependentFields","assemble","transforms","unit","utc","params","push","type","units","timezone","smallestUnit","part","step","expr"],"sources":["../../../../src/compile/data/timeunit.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}