{"ast":null,"code":"import { getMainChannelFromOffsetChannel, isXorYOffset, SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, {\n  ignoreRange\n} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n  const {\n    encoding,\n    mark,\n    markDef\n  } = model;\n  const scaleComponents = {};\n  for (const channel of SCALE_CHANNELS) {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n    // Don't generate scale for shape of geoshape\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      continue;\n    }\n    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n      if (!channelHasNestedOffsetScale(encoding, mainChannel)) {\n        // Don't generate scale when the offset encoding shouldn't yield a nested scale\n        if (specifiedScale) {\n          log.warn(log.message.offsetEncodingScaleIgnored(channel));\n        }\n        continue;\n      }\n    }\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale ?? (specifiedScale = {});\n      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n  }\n  return scaleComponents;\n}\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve;\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      (_a = resolve.scale)[channel] ?? (_a[channel] = defaultScaleResolve(channel, model));\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  }\n  // Merge each channel listed in the index\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n  return scaleComponents;\n}","map":{"version":3,"names":["getMainChannelFromOffsetChannel","isXorYOffset","SCALE_CHANNELS","SHAPE","getFieldOrDatumDef","channelHasNestedOffsetScale","log","GEOSHAPE","NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES","scaleCompatible","scaleTypePrecedence","GEOJSON","keys","isUnitModel","defaultScaleResolve","mergeValuesWithExplicit","tieBreakByComparing","ScaleComponent","parseScaleDomain","parseScaleProperty","parseScaleRange","scaleType","parseScales","model","ignoreRange","parseScaleCore","prop","component","scales","parseUnitScaleCore","parseNonUnitScaleCore","encoding","mark","markDef","scaleComponents","channel","fieldOrDatumDef","type","specifiedScale","mainChannel","warn","message","offsetEncodingScaleIgnored","hasNestedOffsetScale","sType","scaleName","value","explicit","scaleTypeTieBreaker","st1","st2","scaleTypeWithExplicitIndex","resolve","child","children","_a","scale","explicitScaleType","childScaleType","getWithExplicit","name","typeWithExplicit","childScale","renameScale","get","merged"],"sources":["../../../../src/compile/scale/parse.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}