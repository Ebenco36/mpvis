{"ast":null,"code":"import { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OPS } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\nfunction parseUnitScaleDomain(model) {\n  const localScaleComponents = model.component.scales;\n  for (const channel of util.keys(localScaleComponents)) {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n      const resolve = facetParent.component.resolve.scale[channel];\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  }\n}\nfunction parseNonUnitScaleDomain(model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n  const localScaleComponents = model.component.scales;\n  for (const channel of util.keys(localScaleComponents)) {\n    let domains;\n    let selectionExtent = null;\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n        }\n        const se = childComponent.get('selectionExtent');\n        if (selectionExtent && se && selectionExtent.param !== se.param) {\n          log.warn(log.message.NEEDS_SAME_SELECTION);\n        }\n        selectionExtent = se;\n      }\n    }\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    const {\n      valid,\n      reason\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {\n      valid\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n  return domain;\n}\nexport function parseDomainForChannel(model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const {\n    encoding\n  } = model;\n  const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {\n      timeUnit,\n      type\n    });\n    return {\n      signal: `{data: ${data}}`\n    };\n  });\n}\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n  // explicit value\n  const normalizedTimeUnit = normalizeTimeUnit(timeUnit)?.unit;\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n  return [domain]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  const {\n    encoding\n  } = model;\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const {\n    type\n  } = fieldOrDatumDef;\n  const timeUnit = fieldOrDatumDef['timeUnit'];\n  if (isDomainUnionWith(domain)) {\n    const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n    const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n    return makeExplicit([...unionWith, ...defaultDomain.value]);\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n  const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n  if (isDatumDef(fieldOrDatumDef)) {\n    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n  const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(DataSourceType.Main);\n    const {\n      field\n    } = fieldOrDatumDef;\n    return makeImplicit([{\n      data,\n      field: vgField({\n        field,\n        aggregate: 'min'\n      })\n    }, {\n      data,\n      field: vgField({\n        field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      const {\n        bin\n      } = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(() => {\n          const signal = model.getSignalName(binSignal);\n          return `[${signal}.start, ${signal}.stop]`;\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(DataSourceType.Main),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel)\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n      field: model.vgField(channel),\n      sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(DataSourceType.Main),\n      field: model.vgField(channel)\n    }]);\n  }\n}\nfunction normalizeSortField(sort, isStackedMeasure) {\n  const {\n    op,\n    field,\n    order\n  } = sort;\n  return {\n    // Apply default op\n    op: op ?? (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {\n      field: util.replacePathInField(field)\n    } : {}),\n    ...(order ? {\n      order\n    } : {})\n  };\n}\nfunction parseSelectionDomain(model, channel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel)?.bin;\n  const domain = isParameterDomain(spec) && spec;\n  const extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain ?? extent, true);\n  }\n}\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel);\n  const sort = fieldDef.sort;\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n  const {\n    stack\n  } = model;\n  const stackDimensions = stack ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)]) : undefined;\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    const {\n      encoding,\n      order\n    } = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {\n      aggregate,\n      field\n    } = fieldDefToSortBy;\n    const isStackedMeasure = stack && !stackDimensions.has(field);\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order\n      }, isStackedMeasure);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field,\n        order\n      }, isStackedMeasure);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n  // sort == null\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  const {\n    aggregate,\n    type\n  } = fieldDef;\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {\n    explicit: v1.explicit,\n    value: [...v1.value, ...v2.value]\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains) {\n  const uniqueDomains = util.unique(domains.map(domain => {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      const {\n        sort: _s,\n        ...domainWithoutSort\n      } = domain;\n      return domainWithoutSort;\n    }\n    return domain;\n  }), util.hash);\n  const sorts = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      const s = d.sort;\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n      return s;\n    }\n    return undefined;\n  }).filter(s => s !== undefined), util.hash);\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        // Get sorts with non-default ops\n        const filteredSorts = sorts.filter(s => isObject(s) && 'op' in s && s.op !== 'min');\n        if (sorts.every(s => isObject(s) && 'op' in s) && filteredSorts.length === 1) {\n          sort = filteredSorts[0];\n        } else {\n          sort = true;\n        }\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(sort) && 'field' in sort) {\n          const sortField = sort.field;\n          if (domain.field === sortField) {\n            sort = sort.order ? {\n              order: sort.order\n            } : true;\n          }\n        }\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n  // only keep sort properties that work with unioned domains\n  const unionDomainSorts = util.unique(sorts.map(s => {\n    if (util.isBoolean(s) || !('op' in s) || isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  let sort;\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n  const allData = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n    return null;\n  }), x => x);\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => d.field),\n      ...(sort ? {\n        sort\n      } : {})\n    };\n    return domain;\n  }\n  return {\n    fields: uniqueDomains,\n    ...(sort ? {\n      sort\n    } : {})\n  };\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n          return field;\n        }\n      }\n    }\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.get('domains').map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}","map":{"version":3,"names":["isObject","isString","isAggregateOp","isArgmaxDef","isArgminDef","MULTIDOMAIN_SORT_OP_INDEX","UNIONDOMAIN_SORT_OP_INDEX","SHARED_DOMAIN_OPS","isBinning","isBinParams","isParameterExtent","getSecondaryRangeChannel","isScaleChannel","binRequiresRange","getFieldOrDatumDef","hasBandEnd","isDatumDef","isFieldDef","valueExpr","vgField","DataSourceType","log","hasDiscreteDomain","isDomainUnionWith","isParameterDomain","DEFAULT_SORT_OP","isSortArray","isSortByEncoding","isSortField","normalizeTimeUnit","util","isDataRefDomain","isDataRefUnionedDomain","isFieldRefUnionDomain","isSignalRef","getBinSignalName","sortArrayIndexField","FACET_SCALE_PREFIX","isFacetModel","isUnitModel","SignalRefWrapper","makeExplicit","makeImplicit","mergeValuesWithExplicit","parseScaleDomain","model","parseUnitScaleDomain","parseNonUnitScaleDomain","localScaleComponents","component","scales","channel","keys","domains","parseDomainForChannel","localScaleCmpt","setWithExplicit","parseSelectionDomain","data","isFaceted","facetParent","parent","resolve","scale","domain","value","replace","child","children","selectionExtent","childComponent","undefined","getWithExplicit","domainsTieBreaker","se","get","param","warn","message","NEEDS_SAME_SELECTION","set","normalizeUnaggregatedDomain","fieldDef","scaleType","scaleConfig","valid","reason","canUseUnaggregatedDomain","useUnaggregatedDomain","getScaleComponent","encoding","scaleDomain","typedFieldDef","config","specifiedScales","x2","x","parseSingleChannelDomain","y2","y","mapDomainToDataSignal","type","timeUnit","map","v","signal","convertDomainIfItIsDateTime","normalizedTimeUnit","unit","fieldOrDatumDef","defaultDomain","unionWith","stack","fieldChannel","offset","requestDataName","Main","field","suffix","sort","domainSort","d","datum","aggregate","bin","isBoolean","Raw","binSuffix","op","binSignal","getSignalName","contains","markDef","normalizeSortField","isStackedMeasure","order","replacePathInField","spec","extent","stackDimensions","Set","groupbyFields","stackBy","s","has","fieldDefToSortBy","unaggregateDomainHasNoEffectForRawField","unaggregateDomainWithNonSharedDomainOp","unaggregatedDomainWithLogScale","v1","v2","property","propertyOf","explicit","mergeConflictingDomainProperty","mergeDomains","uniqueDomains","unique","_s","domainWithoutSort","hash","sorts","filter","length","MORE_THAN_ONE_SORT","filteredSorts","every","sortField","unionDomainSorts","domainSortDropped","allData","fields","getFieldFromDomain","nonUnionDomain","FACETED_INDEPENDENT_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_SOURCE","assembleDomain","scaleComponent","lookupDataSource"],"sources":["../../../../src/compile/scale/domain.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}