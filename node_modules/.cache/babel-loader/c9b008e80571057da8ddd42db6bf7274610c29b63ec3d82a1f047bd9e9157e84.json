{"ast":null,"code":"import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n  constructor(data) {\n    super(null); // source cannot have parent\n    data ?? (data = {\n      name: 'source'\n    });\n    let format;\n    if (!isGenerator(data)) {\n      format = data.format ? {\n        ...omit(data.format, ['parse'])\n      } : {};\n    }\n    if (isInlineData(data)) {\n      this._data = {\n        values: data.values\n      };\n    } else if (isUrlData(data)) {\n      this._data = {\n        url: data.url\n      };\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        // defaultExtension has type string but we ensure that it is DataFormatType above\n        format.type = defaultExtension;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      this._data = {\n        values: [{\n          type: 'Sphere'\n        }]\n      };\n    } else if (isNamedData(data) || isGenerator(data)) {\n      this._data = {};\n    }\n    // set flag to check if generator\n    this._generator = isGenerator(data);\n    // any dataset can be named\n    if (data.name) {\n      this._name = data.name;\n    }\n    if (format && !isEmpty(format)) {\n      this._data.format = format;\n    }\n  }\n  dependentFields() {\n    return new Set();\n  }\n  producedFields() {\n    return undefined; // we don't know what this source produces\n  }\n\n  get data() {\n    return this._data;\n  }\n  hasName() {\n    return !!this._name;\n  }\n  get isGenerator() {\n    return this._generator;\n  }\n  get dataName() {\n    return this._name;\n  }\n  set dataName(name) {\n    this._name = name;\n  }\n  set parent(parent) {\n    throw new Error('Source nodes have to be roots.');\n  }\n  remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n  hash() {\n    throw new Error('Cannot hash sources');\n  }\n  assemble() {\n    return {\n      name: this._name,\n      ...this._data,\n      transform: []\n    };\n  }\n}","map":{"version":3,"names":["isGenerator","isInlineData","isNamedData","isSphereGenerator","isUrlData","contains","isEmpty","omit","DataFlowNode","SourceNode","constructor","data","name","format","_data","values","url","type","defaultExtension","exec","_generator","_name","dependentFields","Set","producedFields","undefined","hasName","dataName","parent","Error","remove","hash","assemble","transform"],"sources":["../../../../src/compile/data/source.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}