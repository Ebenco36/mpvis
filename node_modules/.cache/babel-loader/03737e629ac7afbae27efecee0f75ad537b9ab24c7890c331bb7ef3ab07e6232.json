{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n  clone() {\n    return new FilterInvalidNode(null, {\n      ...this.filter\n    });\n  }\n  constructor(parent, filter) {\n    super(parent);\n    this.filter = filter;\n  }\n  static make(parent, model) {\n    const {\n      config,\n      mark,\n      markDef\n    } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid !== 'filter') {\n      return null;\n    }\n    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type');\n        // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n        if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n        }\n      }\n\n      return aggregator;\n    }, {});\n    if (!keys(filter).length) {\n      return null;\n    }\n    return new FilterInvalidNode(parent, filter);\n  }\n  dependentFields() {\n    return new Set(keys(this.filter));\n  }\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n\n  hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n  assemble() {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {\n        expr: 'datum'\n      });\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(`isValid(${ref})`);\n          vegaFilters.push(`isFinite(+${ref})`);\n        } else {\n          // should never get here\n        }\n      }\n      return vegaFilters;\n    }, []);\n    return filters.length > 0 ? {\n      type: 'filter',\n      expr: filters.join(' && ')\n    } : null;\n  }\n}","map":{"version":3,"names":["isScaleChannel","vgField","fieldRef","isPathMark","hasContinuousDomain","hash","keys","getMarkPropOrConfig","DataFlowNode","FilterInvalidNode","clone","filter","constructor","parent","make","model","config","mark","markDef","invalid","reduceFieldDef","aggregator","fieldDef","channel","scaleComponent","getScaleComponent","scaleType","get","aggregate","field","length","dependentFields","Set","producedFields","assemble","filters","reduce","vegaFilters","ref","expr","type","push","join"],"sources":["../../../../src/compile/data/filterinvalid.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}