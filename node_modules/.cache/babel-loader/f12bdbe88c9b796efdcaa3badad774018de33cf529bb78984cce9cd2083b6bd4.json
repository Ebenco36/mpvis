{"ast":null,"code":"import { toNumber, peek, toSet, array, constant, isNumber, span, isObject, isString, error, isArray } from 'vega-util';\nimport { bisectRight, range, bisect } from 'd3-array';\nimport * as $ from 'd3-scale';\nimport { scaleOrdinal, tickFormat as tickFormat$1 } from 'd3-scale';\nexport { scaleImplicit } from 'd3-scale';\nimport * as $$1 from 'd3-interpolate';\nimport { timeInterval, utcInterval } from 'vega-time';\nfunction bandSpace(count, paddingInner, paddingOuter) {\n  const space = count - paddingInner + paddingOuter * 2;\n  return count ? space > 0 ? space : 1 : 0;\n}\nconst Identity = 'identity';\nconst Linear = 'linear';\nconst Log = 'log';\nconst Pow = 'pow';\nconst Sqrt = 'sqrt';\nconst Symlog = 'symlog';\nconst Time = 'time';\nconst UTC = 'utc';\nconst Sequential = 'sequential';\nconst Diverging = 'diverging';\nconst Quantile = 'quantile';\nconst Quantize = 'quantize';\nconst Threshold = 'threshold';\nconst Ordinal = 'ordinal';\nconst Point = 'point';\nconst Band = 'band';\nconst BinOrdinal = 'bin-ordinal';\n\n// categories\nconst Continuous = 'continuous';\nconst Discrete = 'discrete';\nconst Discretizing = 'discretizing';\nconst Interpolating = 'interpolating';\nconst Temporal = 'temporal';\nfunction invertRange(scale) {\n  return function (_) {\n    let lo = _[0],\n      hi = _[1],\n      t;\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    return [scale.invert(lo), scale.invert(hi)];\n  };\n}\nfunction invertRangeExtent(scale) {\n  return function (_) {\n    const range = scale.range();\n    let lo = _[0],\n      hi = _[1],\n      min = -1,\n      max,\n      t,\n      i,\n      n;\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    for (i = 0, n = range.length; i < n; ++i) {\n      if (range[i] >= lo && range[i] <= hi) {\n        if (min < 0) min = i;\n        max = i;\n      }\n    }\n    if (min < 0) return undefined;\n    lo = scale.invertExtent(range[min]);\n    hi = scale.invertExtent(range[max]);\n    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];\n  };\n}\nfunction band() {\n  const scale = scaleOrdinal().unknown(undefined),\n    domain = scale.domain,\n    ordinalRange = scale.range;\n  let range$1 = [0, 1],\n    step,\n    bandwidth,\n    round = false,\n    paddingInner = 0,\n    paddingOuter = 0,\n    align = 0.5;\n  delete scale.unknown;\n  function rescale() {\n    const n = domain().length,\n      reverse = range$1[1] < range$1[0],\n      stop = range$1[1 - reverse],\n      space = bandSpace(n, paddingInner, paddingOuter);\n    let start = range$1[reverse - 0];\n    step = (stop - start) / (space || 1);\n    if (round) {\n      step = Math.floor(step);\n    }\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) {\n      start = Math.round(start);\n      bandwidth = Math.round(bandwidth);\n    }\n    const values = range(n).map(i => start + step * i);\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n  scale.domain = function (_) {\n    if (arguments.length) {\n      domain(_);\n      return rescale();\n    } else {\n      return domain();\n    }\n  };\n  scale.range = function (_) {\n    if (arguments.length) {\n      range$1 = [+_[0], +_[1]];\n      return rescale();\n    } else {\n      return range$1.slice();\n    }\n  };\n  scale.rangeRound = function (_) {\n    range$1 = [+_[0], +_[1]];\n    round = true;\n    return rescale();\n  };\n  scale.bandwidth = function () {\n    return bandwidth;\n  };\n  scale.step = function () {\n    return step;\n  };\n  scale.round = function (_) {\n    if (arguments.length) {\n      round = !!_;\n      return rescale();\n    } else {\n      return round;\n    }\n  };\n  scale.padding = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      paddingInner = paddingOuter;\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n  scale.paddingInner = function (_) {\n    if (arguments.length) {\n      paddingInner = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n  scale.paddingOuter = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingOuter;\n    }\n  };\n  scale.align = function (_) {\n    if (arguments.length) {\n      align = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return align;\n    }\n  };\n  scale.invertRange = function (_) {\n    // bail if range has null or undefined values\n    if (_[0] == null || _[1] == null) return;\n    const reverse = range$1[1] < range$1[0],\n      values = reverse ? ordinalRange().reverse() : ordinalRange(),\n      n = values.length - 1;\n    let lo = +_[0],\n      hi = +_[1],\n      a,\n      b,\n      t;\n\n    // bail if either range endpoint is invalid\n    if (lo !== lo || hi !== hi) return;\n\n    // order range inputs, bail if outside of scale range\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    if (hi < values[0] || lo > range$1[1 - reverse]) return;\n\n    // binary search to index into scale range\n    a = Math.max(0, bisectRight(values, lo) - 1);\n    b = lo === hi ? a : bisectRight(values, hi) - 1;\n\n    // increment index a if lo is within padding gap\n    if (lo - values[a] > bandwidth + 1e-10) ++a;\n    if (reverse) {\n      // map + swap\n      t = a;\n      a = n - b;\n      b = n - t;\n    }\n    return a > b ? undefined : domain().slice(a, b + 1);\n  };\n  scale.invert = function (_) {\n    const value = scale.invertRange([_, _]);\n    return value ? value[0] : value;\n  };\n  scale.copy = function () {\n    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n  return rescale();\n}\nfunction pointish(scale) {\n  const copy = scale.copy;\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  scale.copy = function () {\n    return pointish(copy());\n  };\n  return scale;\n}\nfunction point() {\n  return pointish(band().paddingInner(1));\n}\nvar map = Array.prototype.map;\nfunction numbers(_) {\n  return map.call(_, toNumber);\n}\nconst slice = Array.prototype.slice;\nfunction scaleBinOrdinal() {\n  let domain = [],\n    range = [];\n  function scale(x) {\n    return x == null || x !== x ? undefined : range[(bisect(domain, x) - 1) % range.length];\n  }\n  scale.domain = function (_) {\n    if (arguments.length) {\n      domain = numbers(_);\n      return scale;\n    } else {\n      return domain.slice();\n    }\n  };\n  scale.range = function (_) {\n    if (arguments.length) {\n      range = slice.call(_);\n      return scale;\n    } else {\n      return range.slice();\n    }\n  };\n  scale.tickFormat = function (count, specifier) {\n    return tickFormat$1(domain[0], peek(domain), count == null ? 10 : count, specifier);\n  };\n  scale.copy = function () {\n    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());\n  };\n  return scale;\n}\n\n/** Private scale registry: should not be exported */\nconst scales = new Map();\nconst VEGA_SCALE = Symbol('vega_scale');\nfunction registerScale(scale) {\n  scale[VEGA_SCALE] = true;\n  return scale;\n}\n\n/**\n * Return true if object was created by a constructor from the vega-scale `scale` function.\n */\nfunction isRegisteredScale(scale) {\n  return scale && scale[VEGA_SCALE] === true;\n}\n\n/**\n * Augment scales with their type and needed inverse methods.\n */\nfunction create(type, constructor, metadata) {\n  const ctr = function scale() {\n    const s = constructor();\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;\n    }\n    s.type = type;\n    return registerScale(s);\n  };\n  ctr.metadata = toSet(array(metadata));\n  return ctr;\n}\n\n/**\n * Registry function for adding and accessing scale constructor functions.\n * The *type* argument is a String indicating the name of the scale type.\n *\n * If the *scale* argument is not specified, this method returns the matching scale constructor in the registry, or `null` if not found.\n * If the *scale* argument is provided, it must be a scale constructor function to add to the registry under the given *type* name.\n * The *metadata* argument provides additional information to guide appropriate use of scales within Vega.\n *\n *  *metadata* can be either a string or string array. The valid string values are:\n * - `\"continuous\"` - the scale is defined over a continuous-valued domain.\n * - `\"discrete\"` - the scale is defined over a discrete domain and range.\n * - `\"discretizing\"` - the scale discretizes a continuous domain to a discrete range.\n * - `\"interpolating\"` - the scale range is defined using a color interpolator.\n * - `\"log\"` - the scale performs a logarithmic transform of the continuous domain.\n * - `\"temporal\"` - the scale domain is defined over date-time values.\n */\nfunction scale(type, scale, metadata) {\n  if (arguments.length > 1) {\n    scales.set(type, create(type, scale, metadata));\n    return this;\n  } else {\n    return isValidScaleType(type) ? scales.get(type) : undefined;\n  }\n}\n\n// identity scale\nscale(Identity, $.scaleIdentity);\n\n// continuous scales\nscale(Linear, $.scaleLinear, Continuous);\nscale(Log, $.scaleLog, [Continuous, Log]);\nscale(Pow, $.scalePow, Continuous);\nscale(Sqrt, $.scaleSqrt, Continuous);\nscale(Symlog, $.scaleSymlog, Continuous);\nscale(Time, $.scaleTime, [Continuous, Temporal]);\nscale(UTC, $.scaleUtc, [Continuous, Temporal]);\n\n// sequential scales\nscale(Sequential, $.scaleSequential, [Continuous, Interpolating]); // backwards compat\nscale(`${Sequential}-${Linear}`, $.scaleSequential, [Continuous, Interpolating]);\nscale(`${Sequential}-${Log}`, $.scaleSequentialLog, [Continuous, Interpolating, Log]);\nscale(`${Sequential}-${Pow}`, $.scaleSequentialPow, [Continuous, Interpolating]);\nscale(`${Sequential}-${Sqrt}`, $.scaleSequentialSqrt, [Continuous, Interpolating]);\nscale(`${Sequential}-${Symlog}`, $.scaleSequentialSymlog, [Continuous, Interpolating]);\n\n// diverging scales\nscale(`${Diverging}-${Linear}`, $.scaleDiverging, [Continuous, Interpolating]);\nscale(`${Diverging}-${Log}`, $.scaleDivergingLog, [Continuous, Interpolating, Log]);\nscale(`${Diverging}-${Pow}`, $.scaleDivergingPow, [Continuous, Interpolating]);\nscale(`${Diverging}-${Sqrt}`, $.scaleDivergingSqrt, [Continuous, Interpolating]);\nscale(`${Diverging}-${Symlog}`, $.scaleDivergingSymlog, [Continuous, Interpolating]);\n\n// discretizing scales\nscale(Quantile, $.scaleQuantile, [Discretizing, Quantile]);\nscale(Quantize, $.scaleQuantize, Discretizing);\nscale(Threshold, $.scaleThreshold, Discretizing);\n\n// discrete scales\nscale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);\nscale(Ordinal, $.scaleOrdinal, Discrete);\nscale(Band, band, Discrete);\nscale(Point, point, Discrete);\nfunction isValidScaleType(type) {\n  return scales.has(type);\n}\nfunction hasType(key, type) {\n  const s = scales.get(key);\n  return s && s.metadata[type];\n}\nfunction isContinuous(key) {\n  return hasType(key, Continuous);\n}\nfunction isDiscrete(key) {\n  return hasType(key, Discrete);\n}\nfunction isDiscretizing(key) {\n  return hasType(key, Discretizing);\n}\nfunction isLogarithmic(key) {\n  return hasType(key, Log);\n}\nfunction isTemporal(key) {\n  return hasType(key, Temporal);\n}\nfunction isInterpolating(key) {\n  return hasType(key, Interpolating);\n}\nfunction isQuantile(key) {\n  return hasType(key, Quantile);\n}\nconst scaleProps = ['clamp', 'base', 'constant', 'exponent'];\nfunction interpolateRange(interpolator, range) {\n  const start = range[0],\n    span = peek(range) - start;\n  return function (i) {\n    return interpolator(start + i * span);\n  };\n}\nfunction interpolateColors(colors, type, gamma) {\n  return $$1.piecewise(interpolate(type || 'rgb', gamma), colors);\n}\nfunction quantizeInterpolator(interpolator, count) {\n  const samples = new Array(count),\n    n = count + 1;\n  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);\n  return samples;\n}\nfunction scaleCopy(scale) {\n  const t = scale.type,\n    s = scale.copy();\n  s.type = t;\n  return s;\n}\nfunction scaleFraction(scale$1, min, max) {\n  const delta = max - min;\n  let i, t, s;\n  if (!delta || !Number.isFinite(delta)) {\n    return constant(0.5);\n  } else {\n    i = (t = scale$1.type).indexOf('-');\n    t = i < 0 ? t : t.slice(i + 1);\n    s = scale(t)().domain([min, max]).range([0, 1]);\n    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);\n    return s;\n  }\n}\nfunction interpolate(type, gamma) {\n  const interp = $$1[method(type)];\n  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;\n}\nfunction method(type) {\n  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');\n}\nconst continuous = {\n  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',\n  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',\n  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',\n  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',\n  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',\n  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',\n  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',\n  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',\n  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',\n  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',\n  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',\n  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',\n  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',\n  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',\n  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',\n  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',\n  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',\n  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',\n  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',\n  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',\n  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',\n  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',\n  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',\n  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',\n  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',\n  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',\n  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',\n  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',\n  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',\n  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',\n  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',\n  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',\n  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',\n  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',\n  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',\n  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',\n  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',\n  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',\n  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',\n  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',\n  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',\n  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',\n  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',\n  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',\n  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',\n  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',\n  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',\n  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',\n  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',\n  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',\n  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',\n  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',\n  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'\n};\nconst discrete = {\n  category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',\n  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',\n  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',\n  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',\n  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',\n  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',\n  accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',\n  dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',\n  paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',\n  pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',\n  pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',\n  set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',\n  set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',\n  set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'\n};\nfunction colors(palette) {\n  const n = palette.length / 6 | 0,\n    c = new Array(n);\n  for (let i = 0; i < n;) {\n    c[i] = '#' + palette.slice(i * 6, ++i * 6);\n  }\n  return c;\n}\nfunction apply(_, f) {\n  for (const k in _) scheme(k, f(_[k]));\n}\nconst schemes = {};\napply(discrete, colors);\napply(continuous, _ => interpolateColors(colors(_)));\nfunction scheme(name, scheme) {\n  name = name && name.toLowerCase();\n  if (arguments.length > 1) {\n    schemes[name] = scheme;\n    return this;\n  } else {\n    return schemes[name];\n  }\n}\nconst SymbolLegend = 'symbol';\nconst DiscreteLegend = 'discrete';\nconst GradientLegend = 'gradient';\nconst defaultFormatter = value => isArray(value) ? value.map(v => String(v)) : String(value);\nconst ascending = (a, b) => a[1] - b[1];\nconst descending = (a, b) => b[1] - a[1];\n\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @param {number} minStep - The desired minimum step between tick values.\n * @return {*} - The tick count or interval function.\n */\nfunction tickCount(scale, count, minStep) {\n  let step;\n  if (isNumber(count)) {\n    if (scale.bins) {\n      count = Math.max(count, scale.bins.length);\n    }\n    if (minStep != null) {\n      count = Math.min(count, Math.floor(span(scale.domain()) / minStep || 1));\n    }\n  }\n  if (isObject(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n  if (isString(count)) {\n    count = scale.type === Time ? timeInterval(count) : scale.type == UTC ? utcInterval(count) : error('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n  return count;\n}\n\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\nfunction validTicks(scale, ticks, count) {\n  let range = scale.range(),\n    lo = range[0],\n    hi = peek(range),\n    cmp = ascending;\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n    cmp = descending;\n  }\n  lo = Math.floor(lo);\n  hi = Math.ceil(hi);\n\n  // filter ticks to valid values within the range\n  // additionally sort ticks in range order (#2579)\n  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);\n  if (count > 0 && ticks.length > 1) {\n    const endpoints = [ticks[0], peek(ticks)];\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter((_, i) => !(i % 2));\n    }\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n  return ticks;\n}\n\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\nfunction tickValues(scale, count) {\n  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();\n}\n\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or\n *   time multi-format specifier object.\n * @return {function(*):string} - The generated label formatter.\n */\nfunction tickFormat(locale, scale, count, specifier, formatType, noSkip) {\n  const type = scale.type;\n  let format = defaultFormatter;\n  if (type === Time || formatType === Time) {\n    format = locale.timeFormat(specifier);\n  } else if (type === UTC || formatType === UTC) {\n    format = locale.utcFormat(specifier);\n  } else if (isLogarithmic(type)) {\n    const varfmt = locale.formatFloat(specifier);\n    if (noSkip || scale.bins) {\n      format = varfmt;\n    } else {\n      const test = tickLog(scale, count, false);\n      format = _ => test(_) ? varfmt(_) : '';\n    }\n  } else if (scale.tickFormat) {\n    // if d3 scale has tickFormat, it must be continuous\n    const d = scale.domain();\n    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);\n  } else if (specifier) {\n    format = locale.format(specifier);\n  }\n  return format;\n}\nfunction tickLog(scale, count, values) {\n  const ticks = tickValues(scale, count),\n    base = scale.base(),\n    logb = Math.log(base),\n    k = Math.max(1, base * count / ticks.length);\n\n  // apply d3-scale's log format filter criteria\n  const test = d => {\n    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));\n    if (i * base < base - 0.5) i *= base;\n    return i <= k;\n  };\n  return values ? ticks.filter(test) : test;\n}\nconst symbols = {\n  [Quantile]: 'quantiles',\n  [Quantize]: 'thresholds',\n  [Threshold]: 'domain'\n};\nconst formats = {\n  [Quantile]: 'quantiles',\n  [Quantize]: 'domain'\n};\nfunction labelValues(scale, count) {\n  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);\n}\nfunction thresholdFormat(locale, scale, specifier) {\n  const _ = scale[formats[scale.type]](),\n    n = _.length;\n  let d = n > 1 ? _[1] - _[0] : _[0],\n    i;\n  for (i = 1; i < n; ++i) {\n    d = Math.min(d, _[i] - _[i - 1]);\n  }\n\n  // tickCount = 3 ticks times 10 for increased resolution\n  return locale.formatSpan(0, d, 3 * 10, specifier);\n}\nfunction thresholdValues(thresholds) {\n  const values = [-Infinity].concat(thresholds);\n  values.max = +Infinity;\n  return values;\n}\nfunction binValues(bins) {\n  const values = bins.slice(0, -1);\n  values.max = peek(bins);\n  return values;\n}\nconst isDiscreteRange = scale => symbols[scale.type] || scale.bins;\nfunction labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {\n  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);\n  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);\n}\nconst formatRange = format => (value, index, array) => {\n  const limit = get(array[index + 1], get(array.max, +Infinity)),\n    lo = formatValue(value, format),\n    hi = formatValue(limit, format);\n  return lo && hi ? lo + ' \\u2013 ' + hi : hi ? '< ' + hi : '\\u2265 ' + lo;\n};\nconst get = (value, dflt) => value != null ? value : dflt;\nconst formatDiscrete = format => (value, index) => index ? format(value) : null;\nconst formatPoint = format => value => format(value);\nconst formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;\nfunction labelFraction(scale) {\n  const domain = scale.domain(),\n    count = domain.length - 1;\n  let lo = +domain[0],\n    hi = +peek(domain),\n    span = hi - lo;\n  if (scale.type === Threshold) {\n    const adjust = count ? span / count : 0.1;\n    lo -= adjust;\n    hi += adjust;\n    span = hi - lo;\n  }\n  return value => (value - lo) / span;\n}\nfunction format(locale, scale, specifier, formatType) {\n  const type = formatType || scale.type;\n\n  // replace abbreviated time specifiers to improve screen reader experience\n  if (isString(specifier) && isTemporal(type)) {\n    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');\n  }\n  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);\n}\nfunction domainCaption(locale, scale, opt) {\n  opt = opt || {};\n  const max = Math.max(3, opt.maxlen || 7),\n    fmt = format(locale, scale, opt.format, opt.formatType);\n\n  // if scale breaks domain into bins, describe boundaries\n  if (isDiscretizing(scale.type)) {\n    const v = labelValues(scale).slice(1).map(fmt),\n      n = v.length;\n    return `${n} boundar${n === 1 ? 'y' : 'ies'}: ${v.join(', ')}`;\n  }\n\n  // if scale domain is discrete, list values\n  else if (isDiscrete(scale.type)) {\n    const d = scale.domain(),\n      n = d.length,\n      v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');\n    return `${n} value${n === 1 ? '' : 's'}: ${v}`;\n  }\n\n  // if scale domain is continuous, describe value range\n  else {\n    const d = scale.domain();\n    return `values from ${fmt(d[0])} to ${fmt(peek(d))}`;\n  }\n}\nexport { Band, BinOrdinal, DiscreteLegend, Diverging, GradientLegend, Identity, Linear, Log, Ordinal, Point, Pow, Quantile, Quantize, Sequential, Sqrt, SymbolLegend, Symlog, Threshold, Time, UTC, bandSpace, domainCaption, interpolate, interpolateColors, interpolateRange, isContinuous, isDiscrete, isDiscretizing, isInterpolating, isLogarithmic, isQuantile, isRegisteredScale, isTemporal, isValidScaleType, labelFormat, labelFraction, labelValues, quantizeInterpolator, registerScale, scale, scaleCopy, scaleFraction, scheme, tickCount, tickFormat, tickValues, validTicks };","map":{"version":3,"names":["toNumber","peek","toSet","array","constant","isNumber","span","isObject","isString","error","isArray","bisectRight","range","bisect","$","scaleOrdinal","tickFormat","tickFormat$1","scaleImplicit","$$1","timeInterval","utcInterval","bandSpace","count","paddingInner","paddingOuter","space","Identity","Linear","Log","Pow","Sqrt","Symlog","Time","UTC","Sequential","Diverging","Quantile","Quantize","Threshold","Ordinal","Point","Band","BinOrdinal","Continuous","Discrete","Discretizing","Interpolating","Temporal","invertRange","scale","_","lo","hi","t","invert","invertRangeExtent","min","max","i","n","length","undefined","invertExtent","band","unknown","domain","ordinalRange","range$1","step","bandwidth","round","align","rescale","reverse","stop","start","Math","floor","values","map","arguments","slice","rangeRound","padding","a","b","value","copy","pointish","point","Array","prototype","numbers","call","scaleBinOrdinal","x","specifier","scales","Map","VEGA_SCALE","Symbol","registerScale","isRegisteredScale","create","type","constructor","metadata","ctr","s","set","isValidScaleType","get","scaleIdentity","scaleLinear","scaleLog","scalePow","scaleSqrt","scaleSymlog","scaleTime","scaleUtc","scaleSequential","scaleSequentialLog","scaleSequentialPow","scaleSequentialSqrt","scaleSequentialSymlog","scaleDiverging","scaleDivergingLog","scaleDivergingPow","scaleDivergingSqrt","scaleDivergingSymlog","scaleQuantile","scaleQuantize","scaleThreshold","has","hasType","key","isContinuous","isDiscrete","isDiscretizing","isLogarithmic","isTemporal","isInterpolating","isQuantile","scaleProps","interpolateRange","interpolator","interpolateColors","colors","gamma","piecewise","interpolate","quantizeInterpolator","samples","scaleCopy","scaleFraction","scale$1","delta","Number","isFinite","indexOf","forEach","m","interp","method","toLowerCase","split","toUpperCase","join","continuous","blues","greens","greys","oranges","purples","reds","blueGreen","bluePurple","greenBlue","orangeRed","purpleBlue","purpleBlueGreen","purpleRed","redPurple","yellowGreen","yellowOrangeBrown","yellowOrangeRed","blueOrange","brownBlueGreen","purpleGreen","purpleOrange","redBlue","redGrey","yellowGreenBlue","redYellowBlue","redYellowGreen","pinkYellowGreen","spectral","viridis","magma","inferno","plasma","cividis","rainbow","sinebow","turbo","browns","tealBlues","teals","warmGreys","goldGreen","goldOrange","goldRed","lightGreyRed","lightGreyTeal","lightMulti","lightOrange","lightTealBlue","darkBlue","darkGold","darkGreen","darkMulti","darkRed","discrete","category10","category20","category20b","category20c","tableau10","tableau20","accent","dark2","paired","pastel1","pastel2","set1","set2","set3","palette","c","apply","f","k","scheme","schemes","name","SymbolLegend","DiscreteLegend","GradientLegend","defaultFormatter","v","String","ascending","descending","tickCount","minStep","bins","interval","every","validTicks","ticks","cmp","ceil","filter","sort","endpoints","tickValues","locale","formatType","noSkip","format","timeFormat","utcFormat","varfmt","formatFloat","test","tickLog","d","formatSpan","base","logb","log","pow","symbols","formats","labelValues","binValues","thresholdValues","thresholdFormat","thresholds","Infinity","concat","isDiscreteRange","labelFormat","formatRange","formatDiscrete","formatPoint","index","limit","formatValue","dflt","labelFraction","adjust","replace","domainCaption","opt","maxlen","fmt"],"sources":["/Users/ebenezerawotoro/Desktop/mpvis_app/node_modules/vega-scale/build/vega-scale.module.js"],"sourcesContent":["import { toNumber, peek, toSet, array, constant, isNumber, span, isObject, isString, error, isArray } from 'vega-util';\nimport { bisectRight, range, bisect } from 'd3-array';\nimport * as $ from 'd3-scale';\nimport { scaleOrdinal, tickFormat as tickFormat$1 } from 'd3-scale';\nexport { scaleImplicit } from 'd3-scale';\nimport * as $$1 from 'd3-interpolate';\nimport { timeInterval, utcInterval } from 'vega-time';\n\nfunction bandSpace (count, paddingInner, paddingOuter) {\n  const space = count - paddingInner + paddingOuter * 2;\n  return count ? space > 0 ? space : 1 : 0;\n}\n\nconst Identity = 'identity';\nconst Linear = 'linear';\nconst Log = 'log';\nconst Pow = 'pow';\nconst Sqrt = 'sqrt';\nconst Symlog = 'symlog';\nconst Time = 'time';\nconst UTC = 'utc';\nconst Sequential = 'sequential';\nconst Diverging = 'diverging';\nconst Quantile = 'quantile';\nconst Quantize = 'quantize';\nconst Threshold = 'threshold';\nconst Ordinal = 'ordinal';\nconst Point = 'point';\nconst Band = 'band';\nconst BinOrdinal = 'bin-ordinal';\n\n// categories\nconst Continuous = 'continuous';\nconst Discrete = 'discrete';\nconst Discretizing = 'discretizing';\nconst Interpolating = 'interpolating';\nconst Temporal = 'temporal';\n\nfunction invertRange (scale) {\n  return function (_) {\n    let lo = _[0],\n      hi = _[1],\n      t;\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    return [scale.invert(lo), scale.invert(hi)];\n  };\n}\n\nfunction invertRangeExtent (scale) {\n  return function (_) {\n    const range = scale.range();\n    let lo = _[0],\n      hi = _[1],\n      min = -1,\n      max,\n      t,\n      i,\n      n;\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    for (i = 0, n = range.length; i < n; ++i) {\n      if (range[i] >= lo && range[i] <= hi) {\n        if (min < 0) min = i;\n        max = i;\n      }\n    }\n    if (min < 0) return undefined;\n    lo = scale.invertExtent(range[min]);\n    hi = scale.invertExtent(range[max]);\n    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];\n  };\n}\n\nfunction band() {\n  const scale = scaleOrdinal().unknown(undefined),\n    domain = scale.domain,\n    ordinalRange = scale.range;\n  let range$1 = [0, 1],\n    step,\n    bandwidth,\n    round = false,\n    paddingInner = 0,\n    paddingOuter = 0,\n    align = 0.5;\n  delete scale.unknown;\n  function rescale() {\n    const n = domain().length,\n      reverse = range$1[1] < range$1[0],\n      stop = range$1[1 - reverse],\n      space = bandSpace(n, paddingInner, paddingOuter);\n    let start = range$1[reverse - 0];\n    step = (stop - start) / (space || 1);\n    if (round) {\n      step = Math.floor(step);\n    }\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) {\n      start = Math.round(start);\n      bandwidth = Math.round(bandwidth);\n    }\n    const values = range(n).map(i => start + step * i);\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n  scale.domain = function (_) {\n    if (arguments.length) {\n      domain(_);\n      return rescale();\n    } else {\n      return domain();\n    }\n  };\n  scale.range = function (_) {\n    if (arguments.length) {\n      range$1 = [+_[0], +_[1]];\n      return rescale();\n    } else {\n      return range$1.slice();\n    }\n  };\n  scale.rangeRound = function (_) {\n    range$1 = [+_[0], +_[1]];\n    round = true;\n    return rescale();\n  };\n  scale.bandwidth = function () {\n    return bandwidth;\n  };\n  scale.step = function () {\n    return step;\n  };\n  scale.round = function (_) {\n    if (arguments.length) {\n      round = !!_;\n      return rescale();\n    } else {\n      return round;\n    }\n  };\n  scale.padding = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      paddingInner = paddingOuter;\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n  scale.paddingInner = function (_) {\n    if (arguments.length) {\n      paddingInner = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n  scale.paddingOuter = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingOuter;\n    }\n  };\n  scale.align = function (_) {\n    if (arguments.length) {\n      align = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return align;\n    }\n  };\n  scale.invertRange = function (_) {\n    // bail if range has null or undefined values\n    if (_[0] == null || _[1] == null) return;\n    const reverse = range$1[1] < range$1[0],\n      values = reverse ? ordinalRange().reverse() : ordinalRange(),\n      n = values.length - 1;\n    let lo = +_[0],\n      hi = +_[1],\n      a,\n      b,\n      t;\n\n    // bail if either range endpoint is invalid\n    if (lo !== lo || hi !== hi) return;\n\n    // order range inputs, bail if outside of scale range\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    if (hi < values[0] || lo > range$1[1 - reverse]) return;\n\n    // binary search to index into scale range\n    a = Math.max(0, bisectRight(values, lo) - 1);\n    b = lo === hi ? a : bisectRight(values, hi) - 1;\n\n    // increment index a if lo is within padding gap\n    if (lo - values[a] > bandwidth + 1e-10) ++a;\n    if (reverse) {\n      // map + swap\n      t = a;\n      a = n - b;\n      b = n - t;\n    }\n    return a > b ? undefined : domain().slice(a, b + 1);\n  };\n  scale.invert = function (_) {\n    const value = scale.invertRange([_, _]);\n    return value ? value[0] : value;\n  };\n  scale.copy = function () {\n    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n  return rescale();\n}\nfunction pointish(scale) {\n  const copy = scale.copy;\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  scale.copy = function () {\n    return pointish(copy());\n  };\n  return scale;\n}\nfunction point() {\n  return pointish(band().paddingInner(1));\n}\n\nvar map = Array.prototype.map;\nfunction numbers(_) {\n  return map.call(_, toNumber);\n}\n\nconst slice = Array.prototype.slice;\n\nfunction scaleBinOrdinal() {\n  let domain = [],\n    range = [];\n  function scale(x) {\n    return x == null || x !== x ? undefined : range[(bisect(domain, x) - 1) % range.length];\n  }\n  scale.domain = function (_) {\n    if (arguments.length) {\n      domain = numbers(_);\n      return scale;\n    } else {\n      return domain.slice();\n    }\n  };\n  scale.range = function (_) {\n    if (arguments.length) {\n      range = slice.call(_);\n      return scale;\n    } else {\n      return range.slice();\n    }\n  };\n  scale.tickFormat = function (count, specifier) {\n    return tickFormat$1(domain[0], peek(domain), count == null ? 10 : count, specifier);\n  };\n  scale.copy = function () {\n    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());\n  };\n  return scale;\n}\n\n/** Private scale registry: should not be exported */\nconst scales = new Map();\nconst VEGA_SCALE = Symbol('vega_scale');\nfunction registerScale(scale) {\n  scale[VEGA_SCALE] = true;\n  return scale;\n}\n\n/**\n * Return true if object was created by a constructor from the vega-scale `scale` function.\n */\nfunction isRegisteredScale(scale) {\n  return scale && scale[VEGA_SCALE] === true;\n}\n\n/**\n * Augment scales with their type and needed inverse methods.\n */\nfunction create(type, constructor, metadata) {\n  const ctr = function scale() {\n    const s = constructor();\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;\n    }\n    s.type = type;\n    return registerScale(s);\n  };\n  ctr.metadata = toSet(array(metadata));\n  return ctr;\n}\n\n/**\n * Registry function for adding and accessing scale constructor functions.\n * The *type* argument is a String indicating the name of the scale type.\n *\n * If the *scale* argument is not specified, this method returns the matching scale constructor in the registry, or `null` if not found.\n * If the *scale* argument is provided, it must be a scale constructor function to add to the registry under the given *type* name.\n * The *metadata* argument provides additional information to guide appropriate use of scales within Vega.\n *\n *  *metadata* can be either a string or string array. The valid string values are:\n * - `\"continuous\"` - the scale is defined over a continuous-valued domain.\n * - `\"discrete\"` - the scale is defined over a discrete domain and range.\n * - `\"discretizing\"` - the scale discretizes a continuous domain to a discrete range.\n * - `\"interpolating\"` - the scale range is defined using a color interpolator.\n * - `\"log\"` - the scale performs a logarithmic transform of the continuous domain.\n * - `\"temporal\"` - the scale domain is defined over date-time values.\n */\nfunction scale(type, scale, metadata) {\n  if (arguments.length > 1) {\n    scales.set(type, create(type, scale, metadata));\n    return this;\n  } else {\n    return isValidScaleType(type) ? scales.get(type) : undefined;\n  }\n}\n\n// identity scale\nscale(Identity, $.scaleIdentity);\n\n// continuous scales\nscale(Linear, $.scaleLinear, Continuous);\nscale(Log, $.scaleLog, [Continuous, Log]);\nscale(Pow, $.scalePow, Continuous);\nscale(Sqrt, $.scaleSqrt, Continuous);\nscale(Symlog, $.scaleSymlog, Continuous);\nscale(Time, $.scaleTime, [Continuous, Temporal]);\nscale(UTC, $.scaleUtc, [Continuous, Temporal]);\n\n// sequential scales\nscale(Sequential, $.scaleSequential, [Continuous, Interpolating]); // backwards compat\nscale(`${Sequential}-${Linear}`, $.scaleSequential, [Continuous, Interpolating]);\nscale(`${Sequential}-${Log}`, $.scaleSequentialLog, [Continuous, Interpolating, Log]);\nscale(`${Sequential}-${Pow}`, $.scaleSequentialPow, [Continuous, Interpolating]);\nscale(`${Sequential}-${Sqrt}`, $.scaleSequentialSqrt, [Continuous, Interpolating]);\nscale(`${Sequential}-${Symlog}`, $.scaleSequentialSymlog, [Continuous, Interpolating]);\n\n// diverging scales\nscale(`${Diverging}-${Linear}`, $.scaleDiverging, [Continuous, Interpolating]);\nscale(`${Diverging}-${Log}`, $.scaleDivergingLog, [Continuous, Interpolating, Log]);\nscale(`${Diverging}-${Pow}`, $.scaleDivergingPow, [Continuous, Interpolating]);\nscale(`${Diverging}-${Sqrt}`, $.scaleDivergingSqrt, [Continuous, Interpolating]);\nscale(`${Diverging}-${Symlog}`, $.scaleDivergingSymlog, [Continuous, Interpolating]);\n\n// discretizing scales\nscale(Quantile, $.scaleQuantile, [Discretizing, Quantile]);\nscale(Quantize, $.scaleQuantize, Discretizing);\nscale(Threshold, $.scaleThreshold, Discretizing);\n\n// discrete scales\nscale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);\nscale(Ordinal, $.scaleOrdinal, Discrete);\nscale(Band, band, Discrete);\nscale(Point, point, Discrete);\nfunction isValidScaleType(type) {\n  return scales.has(type);\n}\nfunction hasType(key, type) {\n  const s = scales.get(key);\n  return s && s.metadata[type];\n}\nfunction isContinuous(key) {\n  return hasType(key, Continuous);\n}\nfunction isDiscrete(key) {\n  return hasType(key, Discrete);\n}\nfunction isDiscretizing(key) {\n  return hasType(key, Discretizing);\n}\nfunction isLogarithmic(key) {\n  return hasType(key, Log);\n}\nfunction isTemporal(key) {\n  return hasType(key, Temporal);\n}\nfunction isInterpolating(key) {\n  return hasType(key, Interpolating);\n}\nfunction isQuantile(key) {\n  return hasType(key, Quantile);\n}\n\nconst scaleProps = ['clamp', 'base', 'constant', 'exponent'];\nfunction interpolateRange(interpolator, range) {\n  const start = range[0],\n    span = peek(range) - start;\n  return function (i) {\n    return interpolator(start + i * span);\n  };\n}\nfunction interpolateColors(colors, type, gamma) {\n  return $$1.piecewise(interpolate(type || 'rgb', gamma), colors);\n}\nfunction quantizeInterpolator(interpolator, count) {\n  const samples = new Array(count),\n    n = count + 1;\n  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);\n  return samples;\n}\nfunction scaleCopy(scale) {\n  const t = scale.type,\n    s = scale.copy();\n  s.type = t;\n  return s;\n}\nfunction scaleFraction(scale$1, min, max) {\n  const delta = max - min;\n  let i, t, s;\n  if (!delta || !Number.isFinite(delta)) {\n    return constant(0.5);\n  } else {\n    i = (t = scale$1.type).indexOf('-');\n    t = i < 0 ? t : t.slice(i + 1);\n    s = scale(t)().domain([min, max]).range([0, 1]);\n    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);\n    return s;\n  }\n}\nfunction interpolate(type, gamma) {\n  const interp = $$1[method(type)];\n  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;\n}\nfunction method(type) {\n  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');\n}\n\nconst continuous = {\n  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',\n  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',\n  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',\n  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',\n  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',\n  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',\n  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',\n  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',\n  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',\n  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',\n  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',\n  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',\n  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',\n  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',\n  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',\n  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',\n  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',\n  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',\n  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',\n  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',\n  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',\n  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',\n  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',\n  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',\n  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',\n  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',\n  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',\n  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',\n  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',\n  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',\n  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',\n  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',\n  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',\n  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',\n  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',\n  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',\n  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',\n  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',\n  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',\n  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',\n  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',\n  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',\n  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',\n  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',\n  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',\n  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',\n  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',\n  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',\n  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',\n  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',\n  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',\n  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',\n  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'\n};\nconst discrete = {\n  category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',\n  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',\n  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',\n  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',\n  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',\n  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',\n  accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',\n  dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',\n  paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',\n  pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',\n  pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',\n  set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',\n  set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',\n  set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'\n};\n\nfunction colors(palette) {\n  const n = palette.length / 6 | 0,\n    c = new Array(n);\n  for (let i = 0; i < n;) {\n    c[i] = '#' + palette.slice(i * 6, ++i * 6);\n  }\n  return c;\n}\nfunction apply(_, f) {\n  for (const k in _) scheme(k, f(_[k]));\n}\nconst schemes = {};\napply(discrete, colors);\napply(continuous, _ => interpolateColors(colors(_)));\nfunction scheme(name, scheme) {\n  name = name && name.toLowerCase();\n  if (arguments.length > 1) {\n    schemes[name] = scheme;\n    return this;\n  } else {\n    return schemes[name];\n  }\n}\n\nconst SymbolLegend = 'symbol';\nconst DiscreteLegend = 'discrete';\nconst GradientLegend = 'gradient';\n\nconst defaultFormatter = value => isArray(value) ? value.map(v => String(v)) : String(value);\nconst ascending = (a, b) => a[1] - b[1];\nconst descending = (a, b) => b[1] - a[1];\n\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @param {number} minStep - The desired minimum step between tick values.\n * @return {*} - The tick count or interval function.\n */\nfunction tickCount(scale, count, minStep) {\n  let step;\n  if (isNumber(count)) {\n    if (scale.bins) {\n      count = Math.max(count, scale.bins.length);\n    }\n    if (minStep != null) {\n      count = Math.min(count, Math.floor(span(scale.domain()) / minStep || 1));\n    }\n  }\n  if (isObject(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n  if (isString(count)) {\n    count = scale.type === Time ? timeInterval(count) : scale.type == UTC ? utcInterval(count) : error('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n  return count;\n}\n\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\nfunction validTicks(scale, ticks, count) {\n  let range = scale.range(),\n    lo = range[0],\n    hi = peek(range),\n    cmp = ascending;\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n    cmp = descending;\n  }\n  lo = Math.floor(lo);\n  hi = Math.ceil(hi);\n\n  // filter ticks to valid values within the range\n  // additionally sort ticks in range order (#2579)\n  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);\n  if (count > 0 && ticks.length > 1) {\n    const endpoints = [ticks[0], peek(ticks)];\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter((_, i) => !(i % 2));\n    }\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n  return ticks;\n}\n\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\nfunction tickValues(scale, count) {\n  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();\n}\n\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or\n *   time multi-format specifier object.\n * @return {function(*):string} - The generated label formatter.\n */\nfunction tickFormat(locale, scale, count, specifier, formatType, noSkip) {\n  const type = scale.type;\n  let format = defaultFormatter;\n  if (type === Time || formatType === Time) {\n    format = locale.timeFormat(specifier);\n  } else if (type === UTC || formatType === UTC) {\n    format = locale.utcFormat(specifier);\n  } else if (isLogarithmic(type)) {\n    const varfmt = locale.formatFloat(specifier);\n    if (noSkip || scale.bins) {\n      format = varfmt;\n    } else {\n      const test = tickLog(scale, count, false);\n      format = _ => test(_) ? varfmt(_) : '';\n    }\n  } else if (scale.tickFormat) {\n    // if d3 scale has tickFormat, it must be continuous\n    const d = scale.domain();\n    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);\n  } else if (specifier) {\n    format = locale.format(specifier);\n  }\n  return format;\n}\nfunction tickLog(scale, count, values) {\n  const ticks = tickValues(scale, count),\n    base = scale.base(),\n    logb = Math.log(base),\n    k = Math.max(1, base * count / ticks.length);\n\n  // apply d3-scale's log format filter criteria\n  const test = d => {\n    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));\n    if (i * base < base - 0.5) i *= base;\n    return i <= k;\n  };\n  return values ? ticks.filter(test) : test;\n}\n\nconst symbols = {\n  [Quantile]: 'quantiles',\n  [Quantize]: 'thresholds',\n  [Threshold]: 'domain'\n};\nconst formats = {\n  [Quantile]: 'quantiles',\n  [Quantize]: 'domain'\n};\nfunction labelValues(scale, count) {\n  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);\n}\nfunction thresholdFormat(locale, scale, specifier) {\n  const _ = scale[formats[scale.type]](),\n    n = _.length;\n  let d = n > 1 ? _[1] - _[0] : _[0],\n    i;\n  for (i = 1; i < n; ++i) {\n    d = Math.min(d, _[i] - _[i - 1]);\n  }\n\n  // tickCount = 3 ticks times 10 for increased resolution\n  return locale.formatSpan(0, d, 3 * 10, specifier);\n}\nfunction thresholdValues(thresholds) {\n  const values = [-Infinity].concat(thresholds);\n  values.max = +Infinity;\n  return values;\n}\nfunction binValues(bins) {\n  const values = bins.slice(0, -1);\n  values.max = peek(bins);\n  return values;\n}\nconst isDiscreteRange = scale => symbols[scale.type] || scale.bins;\nfunction labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {\n  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);\n  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);\n}\nconst formatRange = format => (value, index, array) => {\n  const limit = get(array[index + 1], get(array.max, +Infinity)),\n    lo = formatValue(value, format),\n    hi = formatValue(limit, format);\n  return lo && hi ? lo + ' \\u2013 ' + hi : hi ? '< ' + hi : '\\u2265 ' + lo;\n};\nconst get = (value, dflt) => value != null ? value : dflt;\nconst formatDiscrete = format => (value, index) => index ? format(value) : null;\nconst formatPoint = format => value => format(value);\nconst formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;\nfunction labelFraction(scale) {\n  const domain = scale.domain(),\n    count = domain.length - 1;\n  let lo = +domain[0],\n    hi = +peek(domain),\n    span = hi - lo;\n  if (scale.type === Threshold) {\n    const adjust = count ? span / count : 0.1;\n    lo -= adjust;\n    hi += adjust;\n    span = hi - lo;\n  }\n  return value => (value - lo) / span;\n}\n\nfunction format(locale, scale, specifier, formatType) {\n  const type = formatType || scale.type;\n\n  // replace abbreviated time specifiers to improve screen reader experience\n  if (isString(specifier) && isTemporal(type)) {\n    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');\n  }\n  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);\n}\nfunction domainCaption(locale, scale, opt) {\n  opt = opt || {};\n  const max = Math.max(3, opt.maxlen || 7),\n    fmt = format(locale, scale, opt.format, opt.formatType);\n\n  // if scale breaks domain into bins, describe boundaries\n  if (isDiscretizing(scale.type)) {\n    const v = labelValues(scale).slice(1).map(fmt),\n      n = v.length;\n    return `${n} boundar${n === 1 ? 'y' : 'ies'}: ${v.join(', ')}`;\n  }\n\n  // if scale domain is discrete, list values\n  else if (isDiscrete(scale.type)) {\n    const d = scale.domain(),\n      n = d.length,\n      v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');\n    return `${n} value${n === 1 ? '' : 's'}: ${v}`;\n  }\n\n  // if scale domain is continuous, describe value range\n  else {\n    const d = scale.domain();\n    return `values from ${fmt(d[0])} to ${fmt(peek(d))}`;\n  }\n}\n\nexport { Band, BinOrdinal, DiscreteLegend, Diverging, GradientLegend, Identity, Linear, Log, Ordinal, Point, Pow, Quantile, Quantize, Sequential, Sqrt, SymbolLegend, Symlog, Threshold, Time, UTC, bandSpace, domainCaption, interpolate, interpolateColors, interpolateRange, isContinuous, isDiscrete, isDiscretizing, isInterpolating, isLogarithmic, isQuantile, isRegisteredScale, isTemporal, isValidScaleType, labelFormat, labelFraction, labelValues, quantizeInterpolator, registerScale, scale, scaleCopy, scaleFraction, scheme, tickCount, tickFormat, tickValues, validTicks };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}