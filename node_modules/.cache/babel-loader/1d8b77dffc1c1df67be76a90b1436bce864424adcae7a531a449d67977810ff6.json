{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n  direction: ({\n    direction\n  }) => direction,\n  format: ({\n    fieldOrDatumDef,\n    legend,\n    config\n  }) => {\n    const {\n      format,\n      formatType\n    } = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: ({\n    legend,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    const {\n      formatType\n    } = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: params => {\n    const {\n      legend,\n      legendConfig\n    } = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n  labelOverlap: ({\n    legend,\n    legendConfig,\n    scaleType\n  }) => legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType),\n  symbolType: ({\n    legend,\n    markDef,\n    channel,\n    encoding\n  }) => legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),\n  title: ({\n    fieldOrDatumDef,\n    config\n  }) => fieldDefTitle(fieldOrDatumDef, config, {\n    allowDisabling: true\n  }),\n  type: ({\n    legendType,\n    scaleType,\n    channel\n  }) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  },\n  values: ({\n    fieldOrDatumDef,\n    legend\n  }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n  const vals = legend.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\nexport function getLegendType(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}) {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}) {\n  return legend.direction ?? legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ?? defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}","map":{"version":3,"names":["isArray","isColorChannel","title","fieldDefTitle","valueArray","isContinuousToContinuous","contains","getFirstDefined","isSignalRef","guideFormat","guideFormatType","getFirstConditionValue","legendRules","direction","format","fieldOrDatumDef","legend","config","formatType","type","scaleType","gradientLength","params","legendConfig","defaultGradientLength","labelOverlap","defaultLabelOverlap","symbolType","markDef","channel","encoding","defaultSymbolType","shape","allowDisabling","legendType","undefined","values","vals","mark","shapeChannelDef","markShape","clipHeight","getLegendType","defaultType","timeUnit","getDirection","orient","defaultDirection","model","gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","gradientLengthSignal","sizeType","min","max","sizeSignal","getSizeSignalRef","signal"],"sources":["../../../../src/compile/legend/properties.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}