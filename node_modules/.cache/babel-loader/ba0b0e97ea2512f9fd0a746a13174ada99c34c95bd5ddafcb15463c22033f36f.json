{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, {\n  defaultPos,\n  vgChannel\n}) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const {\n    offset,\n    offsetType\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0.5\n  });\n  // Get default position or position from mark def\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ?\n  // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef,\n    bandPosition: offsetType === 'encoding' ? 0 : undefined\n  });\n  return valueRef ? {\n    [vgChannel || channel]: valueRef\n  } : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n  const {\n    channel,\n    channelDef,\n    scaleName,\n    stack,\n    offset,\n    markDef\n  } = params;\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef,\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef({\n  model,\n  defaultPos,\n  channel,\n  scaleName,\n  scale\n}) {\n  const {\n    markDef,\n    config\n  } = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel\n    });\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          const scaleType = scale.get('type');\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n            // Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {\n            field: {\n              group: 'height'\n            }\n          } : {\n            value: 0\n          };\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: `min(${model.width.signal},${model.height.signal})/2`\n              };\n            case 'theta':\n              return {\n                signal: '2*PI'\n              };\n            case 'x':\n              return {\n                field: {\n                  group: 'width'\n                }\n              };\n            case 'y':\n              return {\n                value: 0\n              };\n          }\n        }\n        break;\n      case 'mid':\n        {\n          const sizeRef = model[getSizeChannel(channel)];\n          return {\n            ...sizeRef,\n            mult: 0.5\n          };\n        }\n    }\n    // defaultPos === null\n    return undefined;\n  };\n}","map":{"version":3,"names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isXorY","isFieldDef","isFieldOrDatumDef","ScaleType","contains","getMarkPropOrConfig","positionOffset","ref","pointPosition","channel","model","defaultPos","vgChannel","encoding","markDef","config","stack","channelDef","channel2Def","scaleName","scale","getScaleComponent","offset","offsetType","bandPosition","defaultRef","pointPositionDefaultRef","valueRef","latitude","longitude","field","getName","positionRef","undefined","params","fieldChannel","type","interpolatedSignalRef","fieldOrDatumDef","startSuffix","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","mainChannel","definedValueOrConfig","widthHeightValueOrSignalRef","scaleType","get","LOG","TIME","UTC","domainDefinitelyIncludesZero","value","group","signal","width","height","sizeRef","mult"],"sources":["../../../../../src/compile/mark/encode/position-point.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}