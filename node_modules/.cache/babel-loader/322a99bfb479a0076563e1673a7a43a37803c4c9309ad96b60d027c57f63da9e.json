{"ast":null,"code":"import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n  if (pattern.startsWith(\"'\") && pattern.endsWith(\"'\") || pattern.startsWith('\"') && pattern.endsWith('\"')) {\n    return pattern.slice(1, -1);\n  }\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\nexport function getImplicitFromFilterTransform(transform) {\n  const implicit = {};\n  forEachLeaf(transform.filter, filter => {\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val = null;\n      // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = (filter.oneOf ?? filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n  const implicit = {};\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel);\n        add({\n          ...fieldDef,\n          type: mainFieldDef.type\n        });\n      }\n    });\n  }\n  // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n  if (isUnitModel(model)) {\n    const {\n      mark,\n      markDef,\n      encoding\n    } = model;\n    if (isPathMark(mark) &&\n    // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n  const implicit = {};\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n  return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n  clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n  constructor(parent, parse) {\n    super(parent);\n    this._parse = parse;\n  }\n  hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  static makeExplicit(parent, model, ancestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (!isGenerator(data) && data?.format?.parse) {\n      explicit = data.format.parse;\n    }\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n    const parse = new Split(explicit, implicit);\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n    return new ParseNode(parent, p);\n  }\n  get parse() {\n    return this._parse;\n  }\n  merge(other) {\n    this._parse = {\n      ...this._parse,\n      ...other.parse\n    };\n    other.remove();\n  }\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n  // format parse depends and produces all fields in its parse\n  producedFields() {\n    return new Set(keys(this._parse));\n  }\n  dependentFields() {\n    return new Set(keys(this._parse));\n  }\n  assembleTransforms(onlyNested = false) {\n    return keys(this._parse).filter(field => onlyNested ? accessPathDepth(field) > 1 : true).map(field => {\n      const expr = parseExpression(field, this._parse[field]);\n      if (!expr) {\n        return null;\n      }\n      const formula = {\n        type: 'formula',\n        expr,\n        as: removePathFromField(field) // Vega output is always flattened\n      };\n\n      return formula;\n    }).filter(t => t !== null);\n  }\n}","map":{"version":3,"names":["isNumber","isString","isMinMaxOp","getMainRangeChannel","isFieldDef","isFieldOrDatumDefForTimeFormat","isScaleFieldDef","isTypedFieldDef","isGenerator","isDateTime","log","forEachLeaf","isPathMark","isFieldEqualPredicate","isFieldGTEPredicate","isFieldGTPredicate","isFieldLTEPredicate","isFieldLTPredicate","isFieldOneOfPredicate","isFieldPredicate","isFieldRangePredicate","isSortField","accessPathDepth","accessPathWithDatum","duplicate","hash","keys","removePathFromField","signalRefOrValue","isFacetModel","isUnitModel","Split","DataFlowNode","unquote","pattern","startsWith","endsWith","slice","parseExpression","field","parse","f","specifier","length","warn","message","unrecognizedParse","getImplicitFromFilterTransform","transform","implicit","filter","val","equal","lte","lt","gt","gte","range","oneOf","timeUnit","getImplicitFromEncoding","model","add","fieldDef","type","aggregate","sort","forEachFieldDef","channel","mainChannel","mainFieldDef","mark","markDef","encoding","order","dimensionChannel","orient","dimensionChannelDef","getImplicitFromSelection","component","selection","name","selCmpt","proj","project","items","ParseNode","clone","_parse","constructor","parent","makeExplicit","ancestorParse","explicit","data","format","makeWithAncestors","parsedAs","getWithExplicit","value","undefined","differentParse","get","copyAll","p","key","combine","parseNothing","merge","other","remove","assembleFormatParse","formatParse","producedFields","Set","dependentFields","assembleTransforms","onlyNested","map","expr","formula","as","t"],"sources":["../../../../src/compile/data/formatparse.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}