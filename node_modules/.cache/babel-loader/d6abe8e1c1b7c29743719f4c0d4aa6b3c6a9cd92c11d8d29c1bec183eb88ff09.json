{"ast":null,"code":"import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  const {\n    config,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {\n      channels: POSITION_SCALE_CHANNELS\n    });\n    if (signal) {\n      return {\n        defined: {\n          signal\n        }\n      };\n    }\n  }\n  return {};\n}\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum',\n        binSuffix: model.stack?.impute ? 'mid' : undefined\n      });\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return {\n      [prop]: signalOrValueRef(value)\n    };\n  }\n  return undefined;\n}","map":{"version":3,"names":["POSITION_SCALE_CHANNELS","hasContinuousDomain","keys","getMarkPropOrConfig","signalOrValueRef","fieldInvalidPredicate","defined","model","config","markDef","invalid","signal","allFieldsInvalidPredicate","channels","filterIndex","reduce","aggregator","channel","scaleComponent","getScaleComponent","scaleType","get","field","vgField","expr","binSuffix","stack","impute","undefined","fields","length","op","map","join","valueIfDefined","prop","value"],"sources":["../../../../../src/compile/mark/encode/defined.ts"],"sourcesContent":[null],"mappings":"AAAA,SAAQA,uBAAuB,QAAO,kBAAkB;AAGxD,SAAQC,mBAAmB,QAAO,gBAAgB;AAClD,SAAcC,IAAI,QAAO,eAAe;AAExC,SAAQC,mBAAmB,EAAEC,gBAAgB,QAAO,cAAc;AAElE,SAAQC,qBAAqB,QAAO,YAAY;AAEhD,OAAM,SAAUC,OAAOA,CAACC,KAAgB;EACtC,MAAM;IAACC,MAAM;IAAEC;EAAO,CAAC,GAAGF,KAAK;EAE/B,MAAMG,OAAO,GAAGP,mBAAmB,CAAC,SAAS,EAAEM,OAAO,EAAED,MAAM,CAAC;EAC/D,IAAIE,OAAO,EAAE;IACX,MAAMC,MAAM,GAAGC,yBAAyB,CAACL,KAAK,EAAE;MAACM,QAAQ,EAAEb;IAAuB,CAAC,CAAC;IAEpF,IAAIW,MAAM,EAAE;MACV,OAAO;QAACL,OAAO,EAAE;UAACK;QAAM;MAAC,CAAC;;;EAG9B,OAAO,EAAE;AACX;AAEA,SAASC,yBAAyBA,CAChCL,KAAgB,EAChB;EAACG,OAAO,GAAG,KAAK;EAAEG;AAAQ,CAAgD;EAE1E,MAAMC,WAAW,GAAGD,QAAQ,CAACE,MAAM,CAAC,CAACC,UAAsB,EAAEC,OAAO,KAAI;IACtE,MAAMC,cAAc,GAAGX,KAAK,CAACY,iBAAiB,CAACF,OAAO,CAAC;IACvD,IAAIC,cAAc,EAAE;MAClB,MAAME,SAAS,GAAGF,cAAc,CAACG,GAAG,CAAC,MAAM,CAAC;MAC5C,MAAMC,KAAK,GAAGf,KAAK,CAACgB,OAAO,CAACN,OAAO,EAAE;QAACO,IAAI,EAAE,OAAO;QAAEC,SAAS,EAAElB,KAAK,CAACmB,KAAK,EAAEC,MAAM,GAAG,KAAK,GAAGC;MAAS,CAAC,CAAC;MAEzG;MACA,IAAIN,KAAK,IAAIrB,mBAAmB,CAACmB,SAAS,CAAC,EAAE;QAC3CJ,UAAU,CAACM,KAAK,CAAC,GAAG,IAAI;;;IAG5B,OAAON,UAAU;EACnB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMa,MAAM,GAAG3B,IAAI,CAACY,WAAW,CAAC;EAChC,IAAIe,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;IACrB,MAAMC,EAAE,GAAGrB,OAAO,GAAG,IAAI,GAAG,IAAI;IAChC,OAAOmB,MAAM,CAACG,GAAG,CAACV,KAAK,IAAIjB,qBAAqB,CAACiB,KAAK,EAAEZ,OAAO,CAAC,CAAC,CAACuB,IAAI,CAAC,IAAIF,EAAE,GAAG,CAAC;;EAEnF,OAAOH,SAAS;AAClB;AAEA,OAAM,SAAUM,cAAcA,CAACC,IAAY,EAAEC,KAAY;EACvD,IAAIA,KAAK,KAAKR,SAAS,EAAE;IACvB,OAAO;MAAC,CAACO,IAAI,GAAG/B,gBAAgB,CAACgC,KAAK;IAAC,CAAC;;EAE1C,OAAOR,SAAS;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}