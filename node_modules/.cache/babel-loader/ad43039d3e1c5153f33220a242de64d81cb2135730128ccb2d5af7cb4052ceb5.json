{"ast":null,"code":"import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, getOffsetScaleChannel, getSizeChannel, isXorY, isXorYOffset, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, XOFFSET, Y, YOFFSET } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef, isFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport { channelHasFieldOrDatum } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { getStepFor, isStep } from '../../spec/base';\nimport { isDiscrete } from '../../type';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromSignalRefOrValue, signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nimport { durationExpr } from '../../timeunit';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nexport function parseUnitScaleRange(model) {\n  const localScaleComponents = model.component.scales;\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      continue;\n    }\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\nfunction getBinStepSignal(model, channel) {\n  const fieldDef = model.fieldDef(channel);\n  if (fieldDef?.bin) {\n    const {\n      bin,\n      field\n    } = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin);\n      // TODO: extract this to be range step signal\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n  const specifiedScale = model.specifiedScales[channel];\n  const {\n    size\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            {\n              const range = specifiedScale.range;\n              if (isArray(range)) {\n                if (isXorY(channel)) {\n                  return makeExplicit(range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n                    return v;\n                  }));\n                }\n              } else if (isObject(range)) {\n                return makeExplicit({\n                  data: model.requestDataName(DataSourceType.Main),\n                  field: range.field,\n                  sort: {\n                    op: 'min',\n                    field: model.vgField(channel)\n                  }\n                });\n              }\n              return makeExplicit(range);\n            }\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n  const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        const step = getPositionStep(sizeValue, model, channel);\n        // Need to be explicit so layer with step wins over layer without step\n        if (step) {\n          return makeExplicit({\n            step\n          });\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      const positionChannel = channel === XOFFSET ? 'x' : 'y';\n      const positionScaleCmpt = model.getScaleComponent(positionChannel);\n      const positionScaleType = positionScaleCmpt.get('type');\n      if (positionScaleType === 'band') {\n        const step = getOffsetStep(sizeValue, scaleType);\n        if (step) {\n          return makeExplicit(step);\n        }\n      }\n    }\n  }\n  const {\n    rangeMin,\n    rangeMax\n  } = specifiedScale;\n  const d = defaultRange(channel, model);\n  if ((rangeMin !== undefined || rangeMax !== undefined) &&\n  // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin ?? d[0], rangeMax ?? d[1]]);\n  }\n  return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {\n    scheme\n  };\n}\nfunction defaultRange(channel, model) {\n  const {\n    size,\n    config,\n    mark,\n    encoding\n  } = model;\n  const getSignalName = model.getSignalName.bind(model);\n  const {\n    type\n  } = getFieldOrDatumDef(encoding[channel]);\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  const {\n    domain,\n    domainMid\n  } = model.specifiedScales[channel];\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          const positionSize = getDiscretePositionSize(channel, size, config.view);\n          if (isStep(positionSize)) {\n            const step = getPositionStep(positionSize, model, channel);\n            return {\n              step\n            };\n          }\n        }\n        // If step is null, use zero to width or height.\n        // Note that we use SignalRefWrapper to account for potential merges and renames.\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        const zero = model.component.scales[channel].get('zero');\n        const rangeMin = sizeRangeMin(mark, zero, config);\n        const rangeMax = sizeRangeMax(mark, size, model, config);\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n    case THETA:\n      return [0, Math.PI * 2];\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(() => {\n          const w = model.getSignalName('width');\n          const h = model.getSignalName('height');\n          return `min(${w},${h})/2`;\n        })];\n      }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case STROKEDASH:\n      return [\n      // TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\nfunction getPositionStep(step, model, channel) {\n  const {\n    encoding\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const offsetChannel = getOffsetScaleChannel(channel);\n  const offsetDef = encoding[offsetChannel];\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)\n  });\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    const offsetScaleName = model.scaleName(offsetChannel);\n    let stepCount = `domain('${offsetScaleName}').length`;\n    if (offsetScaleCmpt.get('type') === 'band') {\n      const offsetPaddingInner = offsetScaleCmpt.get('paddingInner') ?? offsetScaleCmpt.get('padding') ?? 0;\n      const offsetPaddingOuter = offsetScaleCmpt.get('paddingOuter') ?? offsetScaleCmpt.get('padding') ?? 0;\n      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n    }\n    const paddingInner = mergedScaleCmpt.get('paddingInner') ?? mergedScaleCmpt.get('padding');\n    return {\n      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n    };\n  } else {\n    return step.step;\n  }\n}\nfunction getOffsetStep(step, offsetScaleType) {\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)\n  });\n  if (stepFor === 'offset') {\n    return {\n      step: step.step\n    };\n  }\n  return undefined;\n}\nfunction getOffsetRange(channel, model, offsetScaleType) {\n  const positionChannel = channel === XOFFSET ? 'x' : 'y';\n  const positionScaleCmpt = model.getScaleComponent(positionChannel);\n  const positionScaleType = positionScaleCmpt.get('type');\n  const positionScaleName = model.scaleName(positionChannel);\n  if (positionScaleType === 'band') {\n    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n    if (isStep(size)) {\n      // step is for offset\n      const step = getOffsetStep(size, offsetScaleType);\n      if (step) {\n        return step;\n      }\n    }\n    // otherwise use the position\n    return [0, {\n      signal: `bandwidth('${positionScaleName}')`\n    }];\n  } else {\n    // continuous scale\n    const positionDef = model.encoding[positionChannel];\n    if (isFieldDef(positionDef) && positionDef.timeUnit) {\n      const duration = durationExpr(positionDef.timeUnit, expr => `scale('${positionScaleName}', ${expr})`);\n      const padding = model.config.scale.bandWithNestedOffsetPaddingInner;\n      if (padding) {\n        const startRatio = isSignalRef(padding) ? `${padding.signal}/2` : `${padding / 2}`;\n        const endRatio = isSignalRef(padding) ? `(1 - ${padding.signal}/2)` : `${1 - padding / 2}`;\n        return [{\n          signal: `${startRatio} * (${duration})`\n        }, {\n          signal: `${endRatio} * (${duration})`\n        }];\n      }\n      return [0, {\n        signal: duration\n      }];\n    }\n    return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n  }\n}\nfunction getDiscretePositionSize(channel, size, viewConfig) {\n  const sizeChannel = channel === X ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (sizeValue) {\n    return sizeValue;\n  }\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {\n        signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}`\n      };\n    } else {\n      return 0;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n        const min = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(() => `${min.signal} - 1`);\n        }\n      }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n        const pointStep = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"names":["isArray","isNumber","isObject","isBinning","ANGLE","COLOR","FILL","FILLOPACITY","getOffsetScaleChannel","getSizeChannel","isXorY","isXorYOffset","OPACITY","RADIUS","SCALE_CHANNELS","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","THETA","X","XOFFSET","Y","YOFFSET","getFieldOrDatumDef","isFieldDef","isFieldOrDatumDef","getViewConfigDiscreteSize","getViewConfigDiscreteStep","DataSourceType","channelHasFieldOrDatum","log","channelScalePropertyIncompatability","hasContinuousDomain","hasDiscreteDomain","isContinuousToDiscrete","isExtendedScheme","scaleTypeSupportProperty","getStepFor","isStep","isDiscrete","util","isSignalRef","exprFromSignalRefOrValue","signalOrStringValue","getBinSignalName","SignalRefWrapper","makeExplicit","makeImplicit","durationExpr","RANGE_PROPERTIES","parseUnitScaleRange","model","localScaleComponents","component","scales","channel","localScaleCmpt","rangeWithExplicit","parseRangeForChannel","setWithExplicit","getBinStepSignal","fieldDef","bin","field","sizeType","sizeSignal","getName","binned","step","undefined","scaleName","binCount","getSignalName","binSignal","updatedName","specifiedScale","specifiedScales","size","mergedScaleCmpt","getScaleComponent","scaleType","get","property","supportedByScaleType","channelIncompatability","warn","message","scalePropertyNotWorkWithScaleType","range","map","v","bind","fromName","data","requestDataName","Main","sort","op","vgField","parseScheme","sizeChannel","sizeValue","getPositionStep","stepDropped","positionChannel","positionScaleCmpt","positionScaleType","getOffsetStep","rangeMin","rangeMax","d","defaultRange","length","scheme","name","omit","config","mark","encoding","type","domain","domainMid","contains","positionSize","getDiscretePositionSize","view","getOffsetRange","zero","sizeRangeMin","sizeRangeMax","interpolateRange","defaultContinuousToDiscreteCount","Math","PI","w","h","scale","minStrokeWidth","maxStrokeWidth","minOpacity","maxOpacity","offsetChannel","offsetDef","stepFor","offsetIsDiscrete","offsetScaleCmpt","offsetScaleName","stepCount","offsetPaddingInner","offsetPaddingOuter","paddingInner","signal","offsetScaleType","positionScaleName","positionDef","timeUnit","duration","expr","padding","bandWithNestedOffsetPaddingInner","startRatio","endRatio","never","viewConfig","quantileCount","quantizeCount","domainRequiredForThresholdScale","cardinality","f","rMax","rMin","minBandSize","minFontSize","minSize","Error","incompatibleChannel","MAX_SIZE_RANGE_STEP_RATIO","xyStepSignals","x","y","maxBandSize","min","minXYStep","maxFontSize","maxSize","pointStep","pow","widthStep","width","heightStep","height","exprs","join"],"sources":["../../../../src/compile/scale/range.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}