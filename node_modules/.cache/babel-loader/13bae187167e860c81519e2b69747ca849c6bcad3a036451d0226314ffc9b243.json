{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b;\n  axis.encode ?? (axis.encode = {});\n  (_a = axis.encode)[part] ?? (_a[part] = {});\n  (_b = axis.encode[part]).update ?? (_b.update = {});\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  const {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex,\n    ...axis\n  } = axisCmpt.combine();\n  if (disable) {\n    return undefined;\n  }\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition,\n        ...valueOrSignalRef\n      } = propValue;\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n        const vgRef = [...conditions.map(c => {\n          const {\n            test,\n            ...valueOrSignalCRef\n          } = c;\n          return {\n            test: expression(null, test),\n            ...valueOrSignalCRef\n          };\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test,\n              ...valueOrSignalCRef\n            } = c;\n            return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = {\n        ...(grid ? {\n          grid\n        } : {})\n      };\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    const titleString = assembleTitle(title, config);\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {\n        title: titleString\n      } : {}),\n      ...axis,\n      ...(config.aria === false ? {\n        aria: false\n      } : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"names":["array","isArray","AXIS_PARTS","AXIS_PROPERTY_TYPE","CONDITIONAL_AXIS_PROP_INDEX","isConditionalAxisValue","POSITION_SCALE_CHANNELS","defaultTitle","isText","contains","getFirstDefined","isEmpty","replaceAll","isSignalRef","exprFromValueRefOrSignalRef","expression","assembleTitle","title","config","undefined","map","fieldDef","join","setAxisEncode","axis","part","vgProp","vgRef","encode","_a","_b","update","assembleAxis","axisCmpt","kind","opt","header","disable","orient","scale","labelExpr","zindex","combine","prop","propType","propValue","condition","valueOrSignalRef","conditions","propIndex","c","test","valueOrSignalCRef","signalRef","signal","grid","domain","labels","aria","maxExtent","minExtent","ticks","mainExtracted","expr","text","labelAlign","hasAxisPart","titleString","assembleAxisSignals","model","axes","component","signals","channel","get","sizeType","getSizeSignalRef","push","name","assembleAxes","axisComponents","x","y","a","filter"],"sources":["../../../../src/compile/axis/assemble.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}