{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, isXorY, isXorYOffset, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(specifiedScale, channel, fieldDef, mark, hasNestedOffsetScale = false) {\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  const {\n    type\n  } = specifiedScale;\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n    // Check if explicitly specified scale type is supported by the data type\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n    return type;\n  }\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      {\n        if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n          if (channel === 'shape' && fieldDef.type === 'ordinal') {\n            log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n          }\n          return 'ordinal';\n        }\n        if (isXorY(channel) || isXorYOffset(channel)) {\n          if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n            // The rect/bar mark should fit into a band.\n            // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n            return 'band';\n          }\n          if (hasNestedOffsetScale) {\n            // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n            return 'band';\n          }\n        } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n          return 'band';\n        }\n        const dimensionSize = mark[getSizeChannel(channel)];\n        if (isRelativeBandSize(dimensionSize)) {\n          return 'band';\n        }\n        if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis?.tickBand) {\n          return 'band';\n        }\n        // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n        return 'point';\n      }\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n      return 'time';\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'linear';\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"names":["isBinning","getSizeChannel","isColorChannel","isScaleChannel","isXorY","isXorYOffset","rangeType","isFieldDef","isPositionFieldOrDatumDef","log","isRelativeBandSize","channelSupportScaleType","scaleTypeSupportDataType","normalizeTimeUnit","util","POLAR_POSITION_SCALE_CHANNEL_INDEX","scaleType","specifiedScale","channel","fieldDef","mark","hasNestedOffsetScale","defaultScaleType","defaultType","type","undefined","warn","message","scaleTypeNotWorkWithChannel","scaleTypeNotWorkWithFieldDef","discreteChannelCannotEncode","contains","dimensionSize","axis","tickBand","timeUnit","utc","bin","Error","invalidFieldType"],"sources":["../../../../src/compile/scale/type.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}