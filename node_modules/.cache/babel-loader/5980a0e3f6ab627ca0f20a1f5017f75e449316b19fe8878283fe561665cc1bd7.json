{"ast":null,"code":"import { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isBinnedTimeUnit, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n  return c['param'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  const {\n    field,\n    timeUnit,\n    bin,\n    aggregate\n  } = fieldDef;\n  return {\n    ...(timeUnit ? {\n      timeUnit\n    } : {}),\n    ...(bin ? {\n      bin\n    } : {}),\n    ...(aggregate ? {\n      aggregate\n    } : {}),\n    field\n  };\n}\nexport function isSortableFieldDef(fieldDef) {\n  return 'sort' in fieldDef;\n}\nexport function getBandPosition({\n  fieldDef,\n  fieldDef2,\n  markDef: mark,\n  config\n}) {\n  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n    return fieldDef.bandPosition;\n  }\n  if (isFieldDef(fieldDef)) {\n    const {\n      timeUnit,\n      bin\n    } = fieldDef;\n    if (timeUnit && !fieldDef2) {\n      return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n    } else if (isBinning(bin)) {\n      return 0.5;\n    }\n  }\n  return undefined;\n}\nexport function getBandSize({\n  channel,\n  fieldDef,\n  fieldDef2,\n  markDef: mark,\n  config,\n  scaleType,\n  useVlSizeChannel\n}) {\n  const sizeChannel = getSizeChannel(channel);\n  const size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n    vgChannel: sizeChannel\n  });\n  if (size !== undefined) {\n    return size;\n  }\n  if (isFieldDef(fieldDef)) {\n    const {\n      timeUnit,\n      bin\n    } = fieldDef;\n    if (timeUnit && !fieldDef2) {\n      return {\n        band: getMarkConfig('timeUnitBandSize', mark, config)\n      };\n    } else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n      return {\n        band: 1\n      };\n    }\n  }\n  if (isRectBasedMark(mark.type)) {\n    if (scaleType) {\n      if (hasDiscreteDomain(scaleType)) {\n        return config[mark.type]?.discreteBandSize || {\n          band: 1\n        };\n      } else {\n        return config[mark.type]?.continuousBandSize;\n      }\n    }\n    return config[mark.type]?.discreteBandSize;\n  }\n  return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n    // doesn't have to use bandEnd if there is no bandPosition.\n    return getBandPosition({\n      fieldDef,\n      fieldDef2,\n      markDef,\n      config\n    }) !== undefined;\n  }\n  return false;\n}\nexport function isOrderOnlyDef(orderDef) {\n  return orderDef && !!orderDef.sort && !orderDef['field'];\n}\nexport function isConditionalDef(channelDef) {\n  return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  const condition = channelDef?.['condition'];\n  return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n  // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n  return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n  return channelDef?.['type'];\n}\nexport function isDatumDef(channelDef) {\n  return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);\n}\nexport function isUnbinnedQuantitativeFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && cd.type === 'quantitative' && !cd.bin || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n  return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n  return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n  return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n  return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n  return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n  return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n  return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n  // omit properties that don't exist in string field defs\n  return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n  return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef, opt = {}) {\n  let field = fieldDef.field;\n  const prefix = opt.prefix;\n  let suffix = opt.suffix;\n  let argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    let fn;\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        const {\n          bin,\n          aggregate,\n          timeUnit\n        } = fieldDef;\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = (opt.binSuffix ?? '') + (opt.suffix ?? '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = `[\"${field}\"]`;\n            field = `argmax_${aggregate.argmax}`;\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = `[\"${field}\"]`;\n            field = `argmin_${aggregate.argmin}`;\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {\n          fn = timeUnitToString(timeUnit);\n          suffix = (!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix || '') + (opt.suffix ?? '');\n        }\n      }\n    }\n    if (fn) {\n      field = field ? `${fn}_${field}` : fn;\n    }\n  }\n  if (suffix) {\n    field = `${field}_${suffix}`;\n  }\n  if (prefix) {\n    field = `${prefix}_${field}`;\n  }\n  if (opt.forAs) {\n    return removePathFromField(field);\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(def) {\n  switch (def.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n    case 'quantitative':\n      return isFieldDef(def) && !!def.bin;\n    case 'temporal':\n      return false;\n  }\n  throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n  return isScaleFieldDef(def) && isContinuousToDiscrete(def.scale?.type);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  const {\n    field,\n    bin,\n    timeUnit,\n    aggregate\n  } = fieldDef;\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return `${field} (binned)`;\n  } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {\n    const unit = normalizeTimeUnit(timeUnit)?.unit;\n    if (unit) {\n      return `${field} (${getTimeUnitParts(unit).join('-')})`;\n    }\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return `${field} for max ${aggregate.argmax}`;\n    } else if (isArgminDef(aggregate)) {\n      return `${field} for min ${aggregate.argmin}`;\n    } else {\n      return `${titleCase(aggregate)} of ${field}`;\n    }\n  }\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  const {\n    aggregate,\n    bin,\n    timeUnit,\n    field\n  } = fieldDef;\n  if (isArgmaxDef(aggregate)) {\n    return `${field} for argmax(${aggregate.argmax})`;\n  } else if (isArgminDef(aggregate)) {\n    return `${field} for argmin(${aggregate.argmin})`;\n  }\n  const timeUnitParams = timeUnit && !isBinnedTimeUnit(timeUnit) ? normalizeTimeUnit(timeUnit) : undefined;\n  const fn = aggregate || timeUnitParams?.unit || timeUnitParams?.maxbins && 'timeunit' || isBinning(bin) && 'bin';\n  if (fn) {\n    return `${fn.toUpperCase()}(${field})`;\n  } else {\n    return field;\n  }\n}\nexport const defaultTitleFormatter = (fieldDef, config) => {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nlet titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, {\n  allowDisabling,\n  includeDefault = true\n}) {\n  const guideTitle = getGuide(fieldOrDatumDef)?.title;\n  if (!isFieldDef(fieldOrDatumDef)) {\n    return guideTitle ?? fieldOrDatumDef.title;\n  }\n  const fieldDef = fieldOrDatumDef;\n  const def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return guideTitle ?? fieldDef.title ?? def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n  if (isStringFieldOrDatumDef(fieldDef)) {\n    const {\n      format,\n      formatType\n    } = fieldDef;\n    return {\n      format,\n      formatType\n    };\n  } else {\n    const guide = getGuide(fieldDef) ?? {};\n    const {\n      format,\n      formatType\n    } = guide;\n    return {\n      format,\n      formatType\n    };\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  switch (channel) {\n    case 'latitude':\n    case 'longitude':\n      return 'quantitative';\n    case 'row':\n    case 'column':\n    case 'facet':\n    case 'shape':\n    case 'strokeDash':\n      return 'nominal';\n    case 'order':\n      return 'ordinal';\n  }\n  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n    return 'ordinal';\n  }\n  const {\n    aggregate,\n    bin,\n    timeUnit\n  } = fieldDef;\n  if (timeUnit) {\n    return 'temporal';\n  }\n  if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    return 'quantitative';\n  }\n  if (isScaleFieldDef(fieldDef) && fieldDef.scale?.type) {\n    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n      case 'numeric':\n      case 'discretizing':\n        return 'quantitative';\n      case 'time':\n        return 'temporal';\n    }\n  }\n  return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n  if (isFieldOrDatumDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config, opt = {}) {\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  }\n  // If a fieldDef contains a field, we need type.\n  if (isFieldOrDatumDef(channelDef)) {\n    return initFieldOrDatumDef(channelDef, channel, config, opt);\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return {\n      ...channelDef,\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)\n    };\n  }\n  return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n  if (isStringFieldOrDatumDef(fd)) {\n    const {\n      format,\n      formatType,\n      ...rest\n    } = fd;\n    if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n      log.warn(log.message.customFormatTypeNotAllowed(channel));\n      return initFieldOrDatumDef(rest, channel, config, opt);\n    }\n  } else {\n    const guideType = isPositionFieldOrDatumDef(fd) ? 'axis' : isMarkPropFieldOrDatumDef(fd) ? 'legend' : isFacetFieldDef(fd) ? 'header' : null;\n    if (guideType && fd[guideType]) {\n      const {\n        format,\n        formatType,\n        ...newGuide\n      } = fd[guideType];\n      if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n        log.warn(log.message.customFormatTypeNotAllowed(channel));\n        return initFieldOrDatumDef({\n          ...fd,\n          [guideType]: newGuide\n        }, channel, config, opt);\n      }\n    }\n  }\n  if (isFieldDef(fd)) {\n    return initFieldDef(fd, channel, opt);\n  }\n  return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n  let type = datumDef['type'];\n  if (type) {\n    return datumDef;\n  }\n  const {\n    datum\n  } = datumDef;\n  type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n  return {\n    ...datumDef,\n    type\n  };\n}\nexport function initFieldDef(fd, channel, {\n  compositeMark = false\n} = {}) {\n  const {\n    aggregate,\n    timeUnit,\n    bin,\n    field\n  } = fd;\n  const fieldDef = {\n    ...fd\n  };\n  // Drop invalid aggregate\n  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  }\n  // Normalize Time Unit\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n  if (field) {\n    fieldDef.field = `${field}`;\n  }\n  // Normalize bin\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n  if (isBinned(bin) && !isXorY(channel)) {\n    log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n  }\n  // Normalize Type\n  if (isTypedFieldDef(fieldDef)) {\n    const {\n      type\n    } = fieldDef;\n    const fullType = getFullName(type);\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    const newType = defaultType(fieldDef, channel);\n    fieldDef['type'] = newType;\n  }\n  if (isTypedFieldDef(fieldDef)) {\n    const {\n      compatible,\n      warning\n    } = channelCompatibility(fieldDef, channel) || {};\n    if (compatible === false) {\n      log.warn(warning);\n    }\n  }\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    const {\n      sort\n    } = fieldDef;\n    if (isSortByChannel(sort)) {\n      return {\n        ...fieldDef,\n        sort: {\n          encoding: sort\n        }\n      };\n    }\n    const sub = sort.substr(1);\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return {\n        ...fieldDef,\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      };\n    }\n  }\n  if (isFacetFieldDef(fieldDef)) {\n    const {\n      header\n    } = fieldDef;\n    if (header) {\n      const {\n        orient,\n        ...rest\n      } = header;\n      if (orient) {\n        return {\n          ...fieldDef,\n          header: {\n            ...rest,\n            labelOrient: header.labelOrient || orient,\n            titleOrient: header.titleOrient || orient\n          }\n        };\n      }\n    }\n  }\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return {\n      ...bin,\n      maxbins: autoMaxBins(channel)\n    };\n  } else {\n    return bin;\n  }\n}\nconst COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  const type = fieldDef.type;\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: `Channel ${channel} should not be used with a geojson data.`\n    };\n  }\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case FACET:\n      if (!isDiscrete(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case TEXT:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case ANGLE:\n    case THETA:\n    case RADIUS:\n    case DESCRIPTION:\n      return COMPATIBLE;\n    case LONGITUDE:\n    case LONGITUDE2:\n    case LATITUDE:\n    case LATITUDE2:\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n        };\n      }\n      return COMPATIBLE;\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case SIZE:\n    case THETA2:\n    case RADIUS2:\n    case X2:\n    case Y2:\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n        };\n      }\n      return COMPATIBLE;\n    case SHAPE:\n    case STROKEDASH:\n      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n        };\n      }\n      return COMPATIBLE;\n    case ORDER:\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n        };\n      }\n      return COMPATIBLE;\n  }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n  const {\n    formatType\n  } = getFormatMixins(fieldOrDatumDef);\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldOrDatumDef);\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n  return def && (def['type'] === 'temporal' || isFieldDef(def) && !!def.timeUnit);\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, {\n  timeUnit,\n  type,\n  wrapTime,\n  undefinedIfExprNotRequired\n}) {\n  const unit = timeUnit && normalizeTimeUnit(timeUnit)?.unit;\n  let isTime = unit || type === 'temporal';\n  let expr;\n  if (isExprRef(v)) {\n    expr = v.expr;\n  } else if (isSignalRef(v)) {\n    expr = v.signal;\n  } else if (isDateTime(v)) {\n    isTime = true;\n    expr = dateTimeToExpr(v);\n  } else if (isString(v) || isNumber(v)) {\n    if (isTime) {\n      expr = `datetime(${stringify(v)})`;\n      if (isLocalSingleTimeUnit(unit)) {\n        // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n        if (isNumber(v) && v < 10000 || isString(v) && isNaN(Date.parse(v))) {\n          expr = dateTimeToExpr({\n            [unit]: v\n          });\n        }\n      }\n    }\n  }\n  if (expr) {\n    return wrapTime && isTime ? `time(${expr})` : expr;\n  }\n  // number or boolean or normal string\n  return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n  const {\n    type\n  } = fieldOrDatumDef;\n  return values.map(v => {\n    const timeUnit = isFieldDef(fieldOrDatumDef) && !isBinnedTimeUnit(fieldOrDatumDef.timeUnit) ? fieldOrDatumDef.timeUnit : undefined;\n    const expr = valueExpr(v, {\n      timeUnit,\n      type,\n      undefinedIfExprNotRequired: true\n    });\n    // return signal for the expression if we need an expression\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    }\n    // otherwise just return the original value\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only call this method for binned field defs.');\n    return false;\n  }\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}","map":{"version":3,"names":["isArray","isBoolean","isNumber","isString","isAggregateOp","isArgmaxDef","isArgminDef","isCountingAggregateOp","autoMaxBins","binToString","isBinned","isBinning","ANGLE","COLOR","COLUMN","DESCRIPTION","DETAIL","FACET","FILL","FILLOPACITY","getSizeChannel","HREF","isScaleChannel","isSecondaryRangeChannel","isXorY","KEY","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","OPACITY","ORDER","RADIUS","RADIUS2","ROW","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","TEXT","THETA","THETA2","TOOLTIP","URL","X","X2","XOFFSET","Y","Y2","YOFFSET","getMarkConfig","getMarkPropOrConfig","isCustomFormatType","dateTimeToExpr","isDateTime","isExprRef","log","isRectBasedMark","hasDiscreteDomain","isContinuousToDiscrete","SCALE_CATEGORY_INDEX","isSortByChannel","isFacetFieldDef","getTimeUnitParts","isBinnedTimeUnit","isLocalSingleTimeUnit","normalizeTimeUnit","timeUnitToString","getFullName","QUANTITATIVE","flatAccessWithDatum","getFirstDefined","internalField","omit","removePathFromField","replacePathInField","stringify","titleCase","isSignalRef","isConditionalParameter","c","isRepeatRef","field","toFieldDefBase","fieldDef","timeUnit","bin","aggregate","isSortableFieldDef","getBandPosition","fieldDef2","markDef","mark","config","isFieldOrDatumDef","bandPosition","undefined","isFieldDef","type","getBandSize","channel","scaleType","useVlSizeChannel","sizeChannel","size","vgChannel","band","discreteBandSize","continuousBandSize","hasBandEnd","isTypedFieldDef","isOrderOnlyDef","orderDef","sort","isConditionalDef","channelDef","hasConditionalFieldDef","condition","hasConditionalFieldOrDatumDef","hasConditionalValueDef","isValueDef","channelDefType","isDatumDef","isContinuousFieldOrDatumDef","cd","isDiscrete","isNumericDataDef","isUnbinnedQuantitativeFieldOrDatumDef","datum","isScaleFieldDef","isPositionFieldOrDatumDef","isMarkPropFieldOrDatumDef","isStringFieldOrDatumDef","toStringFieldDef","isOpFieldDef","vgField","opt","prefix","suffix","argAccessor","isCount","fn","nofn","op","binSuffix","argmax","argmin","String","includes","forAs","expr","def","Error","message","invalidFieldType","isDiscretizing","scale","verbalTitleFormatter","countTitle","unit","join","functionalTitleFormatter","timeUnitParams","maxbins","toUpperCase","defaultTitleFormatter","fieldTitle","titleFormatter","setTitleFormatter","formatter","resetTitleFormatter","title","fieldOrDatumDef","allowDisabling","includeDefault","guideTitle","getGuide","defaultTitle","axis","legend","header","getFormatMixins","format","formatType","guide","defaultType","getFieldDef","getFieldOrDatumDef","initChannelDef","primitiveType","warn","primitiveChannelDef","value","initFieldOrDatumDef","fd","rest","customFormatTypes","customFormatTypeNotAllowed","guideType","newGuide","initFieldDef","initDatumDef","datumDef","compositeMark","invalidAggregate","normalizeBin","channelShouldNotBeUsedForBinned","fullType","invalidFieldTypeForCountAggregate","newType","compatible","warning","channelCompatibility","encoding","sub","substr","charAt","order","orient","labelOrient","titleOrient","binned","step","COMPATIBLE","channelShouldBeDiscrete","channelShouldBeDiscreteOrDiscretizing","isFieldOrDatumDefForTimeFormat","isTimeFieldDef","valueExpr","v","wrapTime","undefinedIfExprNotRequired","isTime","signal","isNaN","Date","parse","valueArray","values","map","binRequiresRange","console"],"sources":["../../src/channeldef.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}