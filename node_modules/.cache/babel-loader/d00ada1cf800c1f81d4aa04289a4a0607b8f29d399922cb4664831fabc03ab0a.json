{"ast":null,"code":"import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n  const {\n    fill = undefined,\n    stroke = undefined\n  } = ignore.color === 'include' ? color(model) : {};\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapAllFieldsInvalid(model, 'fill', fill),\n    ...wrapAllFieldsInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...nonPosition('fillOpacity', model),\n    ...nonPosition('strokeOpacity', model),\n    ...nonPosition('strokeWidth', model),\n    ...nonPosition('strokeDash', model),\n    ...zindex(model),\n    ...tooltip(model),\n    ...text(model, 'href'),\n    ...aria(model)\n  };\n}\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  const {\n    config,\n    mark,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n    if (test) {\n      return {\n        [channel]: [\n        // prepend the invalid case\n        // TODO: support custom value\n        {\n          test,\n          value: null\n        }, ...array(valueRef)]\n      };\n    }\n  }\n  return valueRef ? {\n    [channel]: valueRef\n  } : {};\n}\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n    return m;\n  }, {});\n}\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      });\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}","map":{"version":3,"names":["array","SCALE_CHANNELS","isPathMark","hasContinuousDomain","keys","VG_MARK_CONFIGS","getMarkPropOrConfig","signalOrValueRef","aria","color","nonPosition","text","tooltip","fieldInvalidPredicate","zindex","wrapCondition","pointPosition","pointOrRangePosition","rangePosition","rectPosition","ALWAYS_IGNORE","Set","baseEncodeEntry","model","ignore","fill","undefined","stroke","markDefProperties","markDef","wrapAllFieldsInvalid","channel","valueRef","config","mark","invalid","test","allFieldsInvalidPredicate","channels","value","reduce","m","prop","has","filterIndex","aggregator","scaleComponent","getScaleComponent","scaleType","get","field","vgField","expr","fields","length","op","map","join"],"sources":["../../../../../src/compile/mark/encode/base.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}