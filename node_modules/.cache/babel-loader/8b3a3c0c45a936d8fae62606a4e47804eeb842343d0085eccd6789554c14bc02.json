{"ast":null,"code":"import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n  const {\n    channel,\n    channelDef,\n    markDef,\n    scale,\n    config\n  } = params;\n  const ref = midPoint(params);\n  // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n  if (\n  // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) &&\n  // and only for continuous scale\n  scale && isContinuousToContinuous(scale.get('type'))) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel,\n      markDef,\n      ref,\n      config\n    });\n  }\n  return ref;\n}\nexport function wrapPositionInvalidTest({\n  fieldDef,\n  channel,\n  markDef,\n  ref,\n  config\n}) {\n  if (isPathMark(markDef.type)) {\n    // path mark already use defined to skip points, no need to do it here.\n    return ref;\n  }\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid === null) {\n    // if there is no invalid filter, don't do the invalid test\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n  return ref;\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  const test = fieldInvalidPredicate(fieldDef, true);\n  const mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n  const zeroValueRef = mainChannel === 'y' ? {\n    field: {\n      group: 'height'\n    }\n  } :\n  // x / angle / radius can all use 0\n  {\n    value: 0\n  };\n  return {\n    test,\n    ...zeroValueRef\n  };\n}\nexport function fieldInvalidPredicate(field, invalid = true) {\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n  const {\n    datum\n  } = datumDef;\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n  return `${stringify(datum)}`;\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n  const ref = {};\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n  if (isDatumDef(fieldDef)) {\n    const {\n      datum\n    } = fieldDef;\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n  if (encode) {\n    const {\n      offset,\n      band\n    } = encode;\n    if (offset) {\n      ref.offset = offset;\n    }\n    if (band) {\n      ref.band = band;\n    }\n  }\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef({\n  scaleName,\n  fieldOrDatumDef,\n  fieldOrDatumDef2,\n  offset,\n  startSuffix,\n  bandPosition = 0.5\n}) {\n  const expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  const start = vgField(fieldOrDatumDef, {\n    expr,\n    suffix: startSuffix\n  });\n  const end = fieldOrDatumDef2 !== undefined ? vgField(fieldOrDatumDef2, {\n    expr\n  }) : vgField(fieldOrDatumDef, {\n    suffix: 'end',\n    expr\n  });\n  const ref = {};\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    const field = bandPosition === 0 ? start : end;\n    ref.field = field;\n  } else {\n    const datum = isSignalRef(bandPosition) ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}` : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;\n    ref.signal = `scale(\"${scaleName}\", ${datum})`;\n  }\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\nexport function binSizeExpr({\n  scaleName,\n  fieldDef\n}) {\n  const start = vgField(fieldDef, {\n    expr: 'datum'\n  });\n  const end = vgField(fieldDef, {\n    expr: 'datum',\n    suffix: 'end'\n  });\n  return `abs(scale(\"${scaleName}\", ${end}) - scale(\"${scaleName}\", ${start}))`;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef,\n  bandPosition\n}) {\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldOrDatumDef(channelDef)) {\n      const scaleType = scale?.get('type');\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition ?? (bandPosition = getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef,\n          config\n        }));\n        const {\n          bin,\n          timeUnit,\n          type\n        } = channelDef;\n        if (isBinning(bin) || bandPosition && timeUnit && type === TEMPORAL) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack?.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {\n              binSuffix: 'mid'\n            }, {\n              offset\n            });\n          }\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              bandPosition,\n              offset\n            });\n          }\n          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset\n          });\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? {\n        binSuffix: 'range'\n      } : {},\n      // no need for bin suffix if there is no scale\n      {\n        offset,\n        // For band, to get mid point, need to offset by half of the band\n        band: scaleType === 'band' ? bandPosition ?? channelDef.bandPosition ?? 0.5 : undefined\n      });\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {\n        offset\n      } : {};\n      return {\n        ...widthHeightValueOrSignalRef(channel, value),\n        ...offsetMixins\n      };\n    }\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return {\n      ...defaultRef,\n      // only include offset when it is non-zero (zero = no offset)\n      ...(offset ? {\n        offset\n      } : {})\n    };\n  }\n  return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n  return signalOrValueRef(value);\n}","map":{"version":3,"names":["isFunction","isString","isCountingAggregateOp","isBinned","isBinning","getMainRangeChannel","X","X2","Y2","binRequiresRange","getBandPosition","isDatumDef","isFieldDef","isFieldOrDatumDef","isTypedFieldDef","isValueDef","vgField","dateTimeToExpr","isDateTime","isExprRef","log","isPathMark","fieldValidPredicate","hasDiscreteDomain","isContinuousToContinuous","TEMPORAL","contains","stringify","isSignalRef","getMarkPropOrConfig","signalOrValueRef","midPointRefWithPositionInvalidTest","params","channel","channelDef","markDef","scale","config","ref","midPoint","aggregate","get","wrapPositionInvalidTest","fieldDef","type","invalid","fieldInvalidTestValueRef","test","fieldInvalidPredicate","mainChannel","zeroValueRef","field","group","value","expr","datumDefToExpr","datumDef","datum","valueRefForFieldOrDatumDef","scaleName","opt","encode","signal","offset","band","interpolatedSignalRef","fieldOrDatumDef","fieldOrDatumDef2","startSuffix","bandPosition","undefined","start","suffix","end","binSizeExpr","channel2Def","stack","defaultRef","scaleType","fieldDef2","bin","timeUnit","impute","binSuffix","channel2","warn","message","channelRequiredForBinned","offsetMixins","widthHeightValueOrSignalRef"],"sources":["../../../../../src/compile/mark/encode/valueref.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}