{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, getMainChannelFromOffsetChannel, getOffsetScaleChannel, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, isXorYOffset, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, UNIT_CHANNELS, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, hasConditionalFieldOrDatumDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isOrderOnlyDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { isContinuous, isDiscrete, QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nimport { isBinnedTimeUnit } from './timeunit';\nexport function channelHasField(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n  return false;\n}\nexport function channelHasFieldOrDatum(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);\n    }\n  }\n  return false;\n}\nexport function channelHasNestedOffsetScale(encoding, channel) {\n  if (isXorY(channel)) {\n    const fieldDef = encoding[channel];\n    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && (isDiscrete(fieldDef.type) || isFieldDef(fieldDef) && fieldDef.timeUnit)) {\n      const offsetChannel = getOffsetScaleChannel(channel);\n      return channelHasFieldOrDatum(encoding, offsetChannel);\n    }\n  }\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  const groupby = [];\n  const bins = [];\n  const timeUnits = [];\n  const aggregate = [];\n  const encoding = {};\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {\n        field,\n        aggregate: aggOp,\n        bin,\n        timeUnit,\n        ...remaining\n      } = channelDef;\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide?.title;\n        let newField = vgField(channelDef, {\n          forAs: true\n        });\n        const newFieldDef = {\n          // Only add title if it doesn't exist\n          ...(isTitleDefined ? [] : {\n            title: title(channelDef, config, {\n              allowDisabling: true\n            })\n          }),\n          ...remaining,\n          // Always overwrite field\n          field: newField\n        };\n        if (aggOp) {\n          let op;\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n          if (op) {\n            const aggregateEntry = {\n              op,\n              as: newField\n            };\n            if (field) {\n              aggregateEntry.field = field;\n            }\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin,\n              field,\n              as: newField\n            });\n            // Add additional groupbys for range and end of bins\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            }\n            // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n            if (isXorY(channel)) {\n              const secondaryChannel = {\n                field: `${newField}_end`\n              };\n              encoding[`${channel}2`] = secondaryChannel;\n            }\n            newFieldDef.bin = 'binned';\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = QUANTITATIVE;\n            }\n          } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            });\n            // define the format type for later compilation\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n            if (formatType) {\n              if (channel === TEXT || channel === TOOLTIP) {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = {\n                  formatType,\n                  ...newFieldDef['legend']\n                };\n              } else if (isXorY(channel)) {\n                newFieldDef['axis'] = {\n                  formatType,\n                  ...newFieldDef['axis']\n                };\n              }\n            }\n          }\n        }\n        // now the field should refer to post-transformed field instead\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def / signal ref / datum def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  const markSupported = supportMark(channel, mark);\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y];\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n  const normalizedEncoding = {};\n  for (const key of keys(encoding)) {\n    if (!isChannel(key)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(key));\n    }\n  }\n  for (let channel of UNIT_CHANNELS) {\n    if (!encoding[channel]) {\n      continue;\n    }\n    const channelDef = encoding[channel];\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n      const positionDef = normalizedEncoding[mainChannel];\n      if (isFieldDef(positionDef)) {\n        if (isContinuous(positionDef.type)) {\n          if (isFieldDef(channelDef) && !positionDef.timeUnit) {\n            // TODO: nesting continuous field instead continuous field should\n            // behave like offsetting the data in data domain\n            log.warn(log.message.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));\n            continue;\n          }\n        }\n      } else {\n        // no x/y, replace it with main channel\n        channel = mainChannel;\n        log.warn(log.message.replaceOffsetWithMainChannel(mainChannel));\n      }\n    }\n    if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n      log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n      channel = THETA;\n    }\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      continue;\n    }\n    // Drop line's size if the field is aggregated.\n    if (channel === SIZE && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n      if (fieldDef?.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        continue;\n      }\n    }\n    // Drop color if either fill or stroke is specified\n    if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      continue;\n    }\n    if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {\n      if (channelDef) {\n        if (channel === ORDER) {\n          const def = encoding[channel];\n          if (isOrderOnlyDef(def)) {\n            normalizedEncoding[channel] = def;\n            continue;\n          }\n        }\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(initFieldDef(fieldDef, channel));\n          }\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === TOOLTIP && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        continue;\n      }\n      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n    }\n  }\n  return normalizedEncoding;\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\nexport function normalizeEncoding(encoding, config) {\n  const normalizedEncoding = {};\n  for (const channel of keys(encoding)) {\n    const newChannelDef = initChannelDef(encoding[channel], channel, config, {\n      compositeMark: true\n    });\n    normalizedEncoding[channel] = newChannelDef;\n  }\n  return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n  const arr = [];\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = array(channelDef);\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n    if (isArray(el)) {\n      for (const channelDef of el) {\n        f.call(thisArg, channelDef, channel);\n      }\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1, channelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n      case X:\n      case Y:\n      case HREF:\n      case DESCRIPTION:\n      case URL:\n      case X2:\n      case Y2:\n      case XOFFSET:\n      case YOFFSET:\n      case THETA:\n      case THETA2:\n      case RADIUS:\n      case RADIUS2:\n      // falls through\n      case LATITUDE:\n      case LONGITUDE:\n      case LATITUDE2:\n      case LONGITUDE2:\n      // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n      case TEXT:\n      case SHAPE:\n      case ANGLE:\n      // falls through\n      // tooltip fields should not be added to group by [falls through]\n      case TOOLTIP:\n        return details;\n      case ORDER:\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n      // but order should group area for stacking (falls through)\n      case DETAIL:\n      case KEY:\n        {\n          const channelDef = encoding[channel];\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            for (const fieldDef of array(channelDef)) {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            }\n          }\n          return details;\n        }\n      case SIZE:\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, size should group lines.\n      // falls through\n      case COLOR:\n      case FILL:\n      case STROKE:\n      case OPACITY:\n      case FILLOPACITY:\n      case STROKEOPACITY:\n      case STROKEDASH:\n      case STROKEWIDTH:\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          const fieldDef = getFieldDef(encoding[channel]);\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n          return details;\n        }\n    }\n  }, []);\n}","map":{"version":3,"names":["array","isArray","isArgmaxDef","isArgminDef","isBinned","isBinning","ANGLE","CHANNELS","COLOR","DESCRIPTION","DETAIL","FILL","FILLOPACITY","getMainChannelFromOffsetChannel","getOffsetScaleChannel","HREF","isChannel","isNonPositionScaleChannel","isSecondaryRangeChannel","isXorY","isXorYOffset","KEY","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","OPACITY","ORDER","RADIUS","RADIUS2","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","supportMark","TEXT","THETA","THETA2","TOOLTIP","UNIT_CHANNELS","URL","X","X2","XOFFSET","Y","Y2","YOFFSET","binRequiresRange","getFieldDef","getGuide","hasConditionalFieldDef","hasConditionalFieldOrDatumDef","initChannelDef","initFieldDef","isConditionalDef","isDatumDef","isFieldDef","isOrderOnlyDef","isTypedFieldDef","isValueDef","title","vgField","log","isContinuous","isDiscrete","QUANTITATIVE","TEMPORAL","keys","some","isSignalRef","isBinnedTimeUnit","channelHasField","encoding","channel","channelDef","fieldDef","field","channelHasFieldOrDatum","channelHasNestedOffsetScale","type","timeUnit","offsetChannel","isAggregate","aggregate","extractTransformsFromEncoding","oldEncoding","config","groupby","bins","timeUnits","forEach","aggOp","bin","remaining","guide","isTitleDefined","newField","forAs","newFieldDef","allowDisabling","op","argmax","argmin","aggregateEntry","as","push","binSuffix","secondaryChannel","formatType","markChannelCompatible","mark","markSupported","primaryFieldDef","initEncoding","filled","normalizedEncoding","key","warn","message","invalidEncodingChannel","mainChannel","positionDef","offsetNestedInsideContinuousPositionScaleDropped","replaceOffsetWithMainChannel","theta","REPLACE_ANGLE_WITH_THETA","incompatibleChannel","LINE_WITH_VARYING_SIZE","droppingColor","fill","stroke","def","reduce","defs","emptyFieldDef","normalizeEncoding","newChannelDef","compositeMark","fieldDefs","arr","channelDefArray","condition","mapping","f","thisArg","el","call","init","r","map","r1","pathGroupingFields","details"],"sources":["../../src/encoding.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}